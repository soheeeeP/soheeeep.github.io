---
emoji: 🐤
title: HTTP/2.0 프로토콜 알아보기
date: '2023-06-03 11:04:00'
author: 소희
tags: blog gatsby theme 개츠비 테마
categories: 네트워크
---

[이전 포스팅: <어떤 API를 사용해야 할까? - REST, GraphQL, 그리고 GRPC>](https://soheeeep.github.io/api-architecture)에서 다양한 API 형식에 대하여 소개했다. 그 중 REST는 `HTTP/1.1` 프로토콜을 기반으로 동작한다면, gRPC는 `HTTP/2.0` 프로콜을 기반으로 동작한다는 점이 가장 큰 차이점이었다. 

그동안 HTTP와 HTTPS를 **'웹에서 동작하는 어플리케이션을 만들기 위해 정의된 클라이언트-서버 모델의 프로토콜'** 정도의 넓은 개념으로만 이해하고 있었다. 시간의 흐름에 따라 발전해온 HTTP 프로토콜의 버전과 그 특징에 대하여 자세하게 알아보려고 한다.

<br>

## 웹은 어떻게 동작하는가?
인터넷이 메세지를 routing할 수 있는 `IP(Internet Protocol)`을 기반으로 연결된 public한 computer들의 집합이라는 넓은 개념이라면, Web은 이메일, 파일 공유처럼 인터넷을 구성하는 여러 서비스 중 하나라고 말할 수 있다.
> **_IP(Internel Protocol)_:** 송신 호스트와 수신 호스트 사이에서 패킷이 네트워크를 통해 이동할 수 있도록 데이터를 라우팅하는 네트워크 계층의 프로토콜

각 서비스에 대하여 인터넷을 통해 메세지를 라우팅하고 리소스를 주고받기 위한 표준과 프로토콜이 존재한다.
이메일이 `SMTP, IMAP, POP 프로토콜`을 이용한다면, web은 `HTTP`을 통해 멀리 떨어진 다른 서버에 대한 리소스를 요청하고 응답받는다.

<br>

## HTTP의 정의와 동작 방식

`HTTP(Hypertext Transfer Protocol)`은 여러 종류의 파일(문서에 대한 링크, 이미지와 같은 다양한 형태)을 주고받는 프로토콜이다. HTTP는 신뢰성 있는 네트워크를 기반으로 동작하고, 여러 계층으로 나누어 통신을 수행한다. 각 계층은 독립적이지만 논리적으로 연결되어 있다. 

![web-http-transport-layer.jpeg](./web-http-transport-layer.jpeg)*가장 보편적으로 적용되는 OSI(Open Systems Interconection) 7계층 모델*

<br>

### 전송(Transport) 계층의 프로토콜, TCP와 UDP

데이터를 주고받는 전송 계층의 프로토콜 중 가장 대표적인 것에는 `TCP(Transmission Control Protocol)`과 `UDP(User Diagram Protocol)`이 있다. IP를 통해 전달되는 패킷에 대한 오류 검출, 재전송 요구 제어 등을 수행하여 데이터를 전달해주는 역할을 수행한다.

|   | TCP | UDP |
|:--:|:--- |:---|
| 연결 방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 | 가상회선 방식 | 데이터그램 방식 |
| 전송 속도 | 느림 | 빠름 |
| 연결 설정 | handshaking을 통해 연결을 설정하고<br>해제하는 과정이 존재하지 않음 | 연결을 설정하기 위한<br>별도의 과정이 존재하지 않음 |
| 신뢰성 | 데이터의 전송순서를 보장하며, <br>신뢰성이 높음 | 데이터의 전송순서를 보장하지 않으며,<br>신뢰성이 낮음 |

위의 표를 통해 **TCP는 신뢰성이 높지만 상대적으로 느린, UDP는 신뢰성이 낮지만 상대적으로 빠른 프로토콜**이라고 정리할 수 있다. TCP는 전송되는 데이터 패킷들의 순서를 보장하고, 패킷 손실 여부 등을 검사하여 송신 측에서 보낸 데이터가 수신 측에 온전하게 전달되는 것을 보장한다.

<br>

### HTTP/1.0

`HTTP/1.0`에서는 문서뿐만 아니라 이미지, CSS와 같이 다양한 파일을 주고 받을 수 있다.  
- **하나의 TCP 연결에 대해 하나의 요청을 처리할 수 있도록 구현**되어있다. 세션을 유지하지 않으므로, TCP 연결을 지속하려면 `Connection: keep-alive` 헤더를 설정해야 해주어야 하는 `Non-Persistent` 프토토콜이다.
- **`Pipelining`을 제공하지 않아 하나의 요청에 대한 응답을 받은 후에 다른 요청을 수행할 수 있으므로**, `RTT(Round Trip Time)`이 증가하고 network latency가 발생하게 된다.
- **하나의 IP 주소에 대하여 여러 도메인을 운영할 수 없고**, 클라이언트와 서버 사이에 proxy가 위치하는 경우 **proxy가 클라이언트에 대한 인증을 수행할 수 없다**는 한계가 있었다.

<br>

### HTTP/1.1

`HTTP/1.0`과 가장 크게 달라진 점은 **TCP 연결의 지속성**이다.  
- **별도의 헤더를 설정하지 않고도 지정된 timeout 동안은 연결을 유지**한다. 또한 요청마다 TCP 연결을 수립해야 하는 `HTTP/1.0`과 달리, 한 개의 TCP 세션을 통해 여러 요청을 처리하여 부하를 줄일 수 있게 `Persistent`한 프로토콜로 개선되었다.
- **연결 내에서 응답을 기다리지 않고 순차적으로 여러 요청을 보낼 수 있는 `Pipelining`이 적용**되며 network latency가 개선되었다.
- Host 헤더를 추가하여 **하나의 IP에 여러 도메인을 운영하는** `Virtual Hosting`이 가능해졌다.
- `proxy-authentication`, `proxy-authorization` 헤더를 사용하여 proxy도 클라이언트에 대한 인증을 수행할 수 있게 되며 **인증절차가 강화**되었다.
- 새로운 상태 코드가 추가되고, caching이 개선되는 등 전체적인 성능이 향상되었다.

![web-http-1.0-1.1.png](./web-http-1.0-1.1.png)

<br>

### HOLB(Head of Line Blocking)

기본적으로 `HTTP/1`에서는 TCP 프로토콜을 사용하므로, 패킷은 무조건 전송받은 순서대로 처리되는 것이 보장된다. 수신 측은 송신 측과 sequence 번호를 주고받으며 순서대로 패킷을 재조립하고, 패킷이 손실 또는 유실되었을 경우 재전송을 수행하게 된다. 요청이 처리되는 순서가 정해져 있으므로, 이전에 받은 패킷을 파싱하기 전가지는 다음 패킷을 처리할 수도 없어서 `Pipelining`을 활용하는 것 또한 쉽지 않다. 이렇게 **패킷이 유실되거나 송신 측의 전송 속도와 수신 측의 패킷 처리 속도가 상이한 경우 발생하는 병목현상**을 `HOLB(Head of Line Blocking)`라고 부른다.

또한 TCP에서는 신뢰성 있는 연결을 위해 handshaking을 반복적으로 수행하기 때문에 여전히 불필요한 `RTT(Round Trip Time)`, 이에 따른 네트워크 지연이 발생한다는 문제도 남아있다.

### 다수의 요청으로 인해 무거워지는 Header

클라이언트와 서버 사이의 요청을 처리할 때마다 헤더를 중복해서 전송하며 불필요한 데이터를 주고받게 된다. cookie 정보 또한 매 요청마다 헤더에 포함되어 전송하므로 네트워크 자원이 낭비되는 문제가 발생한다.

<br>

<text style="color:grey;">

## HTTP/2의 출현

### HTTP/2의 Message와 Streaming

### HTTP/2 기반으로 동작하는 RPC

<br>

## UDP 기반으로 동작하는 HTTP?

### HTTP/3

### UDP 기반으로 동작하는 프로토콜, QUIC

### HTTP/3이 UDP를 사용함으로서 얻은 이점


</text>


```toc
```
{"componentChunkName":"component---src-templates-blog-template-js","path":"/web-http/","result":{"data":{"cur":{"id":"0b79f502-ecd3-5900-934b-025c9237986d","html":"<p><a href=\"https://soheeeep.github.io/api-architecture\">이전 포스팅: &#x3C;어떤 API를 사용해야 할까? - REST, GraphQL, 그리고 GRPC></a>에서 다양한 API 형식에 대하여 소개했다. 그 중 REST는 <code class=\"language-text\">HTTP/1.1</code> 프로토콜을 기반으로 동작한다면, gRPC는 <code class=\"language-text\">HTTP/2.0</code> 프로콜을 기반으로 동작한다는 점이 가장 큰 차이점이었다.</p>\n<p>그동안 HTTP와 HTTPS를 ‘웹에서 동작하는 어플리케이션을 만들기 위해 정의된 클아이언트-서버 모델의 프로토콜’ 정도의 넓은 개념으로만 이해하고 있었다. 시간의 흐름에 따라 발전해온 HTTP 프로토콜의 버전과 그 특징에 대하여 자세하게 알아보려고 한다.</p>","excerpt":"이전 포스팅: <어떤 API를 사용해야 할까? - REST, GraphQL, 그리고 GRPC>에서 다양한 API 형식에 대하여 소개했다. 그 중 REST는  프로토콜을 기반으로 동작한다면, gRPC는  프로콜을 기반으로 동작한다는 점이 가장 큰 차이점이었다. 그동안 HTTP와 HTTPS를 ‘웹에서 동작하는 어플리케이션을 만들기 위해 정의된 클아이언트-서버 모델의 프로토콜’ 정도의 넓은 개념으로만 이해하고 있었다. 시간의 흐름에 따라 발전해온 HTTP 프로토콜의 버전과 그 특징에 대하여 자세하게 알아보려고 한다.","frontmatter":{"date":"June 03, 2023","title":"HTTP/2.0 프로토콜 알아보기","categories":"네트워크","author":"소희","emoji":"🐤"},"fields":{"slug":"/web-http/"}},"next":{"id":"36b6c771-3e4a-5b9a-8aed-913d8230f89f","html":"<p><code class=\"language-text\">API(Application Programming Interface)</code>는 <strong>서비스와 서비스끼리 통신하기 위해, 즉 요청과 응답을 주고받기 위해 정의된 다양한 종류의 인터페이스</strong>이다. ‘다양한 서비스가 만나는 지점’이자 ‘서비스의 동작을 정의한 일종의 약속’이라고도 표현할 수 있을 것 같다. 실제 서비스를 제공하기 위해서는 무수히 많은 소프트웨어 서비스가 맞물려서 운영되어야 하기 때문에, 구체적이고 확장성이 높은 API를 정의하는 것은 매우 중요하다.</p>\n<br>\n<h2 id=\"api는-어떤-방식으로-동작할까\" style=\"position:relative;\"><a href=\"#api%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C\" aria-label=\"api는 어떤 방식으로 동작할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API는 어떤 방식으로 동작할까?</h2>\n<p>API는 클라이언트와 서버 사이에서 요청과 응답을 통해 리소스를 주고받는 방식으로 동작한다.<br>\nAPI를 구성하는 요소들은 아래와 같다.</p>\n<h3 id=\"자원resource\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%9B%90resource\" aria-label=\"자원resource permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자원(resource)</h3>\n<p>‘이 리소스를 어떻게 명확하게 표현할 수 있을지?‘가 바로 API가 풀어내야 할 과제가 된다. 여기서 <strong>리소스는 DB에 저장된 데이터 자체가 아닌, 데이터의 상태를 클라이언트가 요청한 방식에 맞추어 표현하여 전달한 응답</strong>이다. 리소스는 JSON 데이터일수도, 이미지일수도 또는 어떠한 문서일수도 있다.</p>\n<h3 id=\"동작method\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91method\" aria-label=\"동작method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작(method)</h3>\n<p>또한 리소스에 대해 <strong>어떤 동작을 수행할 것인지를</strong> 정의한다. 리소스를 생성(<code class=\"language-text\">POST</code>)할 것인지, 단순히 가져올 것인지(<code class=\"language-text\">GET</code>)와 같은 행위를 명시해야 한다.</p>\n<br>\n<h2 id=\"api의-종류에-대해-알아보자\" style=\"position:relative;\"><a href=\"#api%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" aria-label=\"api의 종류에 대해 알아보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API의 종류에 대해 알아보자</h2>\n<p>API의 형식은 게속해서 발전하여 왔다. 그 중 가장 보편화된 3가지 방식에 대해 설명해보려 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtUlEQVQoz2WQW2/aQBBGxzZgcNiLL7sLGLC99oJh7bUhSCStmpKkD22TVJX62Pal//9HVA5pVLXSeZj5RmdGGnDC9eH0tb7+rK8+fvr2S+0/3D39zMwJkLSDteWv/sf+U0AvKpu3j8vqJjOnu8cfu3dfbh++y+b2LANV/8pUASleZKDKwTmKWxhLGC5hnHmi6oUlUGUH6yA9/H0fqOpHG7zYddOz7E2qRN9Y/soJSyAqrd/jeQtIonmr9vfetAbych9IEWQHaU7O80YAUvSjki53QAqgCqgKkssB2wCWFzMjiuOAb19HQAqy3M1W105UduEFrya8iVk7ENuxqJhoBDMRM4Fo+mw7Cc2YVZTXrtBDoV2hR0zHUeNz44kKKK+nrEG8crn2uJ4wQ3jNuAmYcYX2edfGvB1w7T4zEpqyOmbtiGtw+QbHBrAEkvd8JeQBUDqe1XTZdiGWLivDZA8oA5KfsWgeppfdw8i8nq+PFs4AZ2hWJds3PT/3FyZM2k5AKZ3X8fpoEfmKTeSivOqHCkZsRWJt4RRQ0tUz7VA5jNQwUoASQMkwUmiysUlm4fSMjVM87ZLfnJg8qhsksSIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-architecture-timeline.png\"\n        title=\"api-architecture-timeline.png\"\n        src=\"/static/55ea0de85b54807e674dddd161c9c12e/37523/api-architecture-timeline.png\"\n        srcset=\"/static/55ea0de85b54807e674dddd161c9c12e/e9ff0/api-architecture-timeline.png 180w,\n/static/55ea0de85b54807e674dddd161c9c12e/f21e7/api-architecture-timeline.png 360w,\n/static/55ea0de85b54807e674dddd161c9c12e/37523/api-architecture-timeline.png 720w,\n/static/55ea0de85b54807e674dddd161c9c12e/b4098/api-architecture-timeline.png 816w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<h3 id=\"restrepresential-state-transfer\" style=\"position:relative;\"><a href=\"#restrepresential-state-transfer\" aria-label=\"restrepresential state transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST(REpresential State Transfer)</h3>\n<p><code class=\"language-text\">REST(REpresential State Transfer)</code>는 HTTP 프로토콜 위에서 동작하는, 가장 보편적으로 쓰이는 API 형식이다. URL과 HTTP method(<code class=\"language-text\">GET</code>, <code class=\"language-text\">POST</code>, <code class=\"language-text\">PATCH</code>, <code class=\"language-text\">DELETE</code>)를 사용하여 리소스에 접근한다.</p>\n<p><code class=\"language-text\">REST</code>는 <strong>stateless</strong>한 특징을 가지며 <strong>caching</strong>을 적용하여 클라이언트와 서버가 지속적으로 연결을 수립할 필요가 없게 구현할 수 있다. 또한 다양한 프로그래밍 언어로 구현할 수 있고, 일반 텍스트, <code class=\"language-text\">HTML</code>, <code class=\"language-text\">YAML</code>, <code class=\"language-text\">XML</code>, <code class=\"language-text\">JSON</code>과 같이 <strong>다양한 포맷으로 리소스를 주고받을 수 있다</strong>는 장점이 있다. 주로 JSON 포맷으로 데이터를 주고 받는다.</p>\n<p>반면, <text style=\"color:#000066;\"><strong>클라이언트는 언제나 요청된 endpoint에서 정의된 리소스만 받아올 수 있다는 단점도 있다.</strong></text>\n한 번의 요청에 불필요한 리소스까지 모두 포함되거나(over-fetching), 클라이언트가 필요로 하는 데이터를 얻기 위해서는 여러 번의 서로 다른 요청(under-fetching)을 보내게 될 수 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># curL을 사용한 REST API 요청</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-i</span> <span class=\"token parameter variable\">-X</span> GET http://localhost:8080/api/books</code></pre></div>\n<br>\n<h3 id=\"graphql\" style=\"position:relative;\"><a href=\"#graphql\" aria-label=\"graphql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL</h3>\n<p>Facebook에서 개발한 API를 위한 query 언어이다.\nREST API와 달리 리소스에 대한 별도의 endpoint가 존재하지 않고, <strong>하나의 endpoint만 존재</strong>한다.</p>\n<p>필요한 컬럼에 대해서만 선택적으로 요청을 보낼 수 있어 클라이언트가 필요로 하는 데이터만 받을 수 있다는 것이 가장 큰 장점이다. 여러 depth로 구성된 데이터에 접근하는 경우에도, 요청을 여러 번 보내지 않고 효율적으로 리소스를 주고 받을 수 있다. <em><strong>즉, 사용자는 한 번의 요청만으로 원하는 데이터를 전부 응답받을 수 있다.</strong></em></p>\n<p>또한 HTTP Method에 따라 리소스에 대한 접근 방식이 달랐던 REST API는 달리 <code class=\"language-text\">POST</code> method만을 사용하여 <code class=\"language-text\">Query</code>, <code class=\"language-text\">Mutation</code>, <code class=\"language-text\">Subscription</code> 3가지 방식으로 동작한다.</p>\n<ul>\n<li><code class=\"language-text\">Query</code>: 데이터를 요청할 때 사용하는 방식\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># curL을 사용한 GraphQL query 요청</span>\n<span class=\"token function\">curl</span>  <span class=\"token string\">'http://snowtooth.herokuapp.com/'</span>\n<span class=\"token parameter variable\">-H</span> <span class=\"token string\">'Content-Type: application/json'</span>\n<span class=\"token parameter variable\">--data</span> <span class=\"token string\">'{\"query\":\"{ query { books {id, name}}}\"}'</span></code></pre></div>\n</li>\n<li><code class=\"language-text\">Mutation</code>: 데이터를 조작할 때(<code class=\"language-text\">INSERT</code>, <code class=\"language-text\">UPDATE</code>, <code class=\"language-text\">DELETE</code>) 사용하는 방식\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token string\">'http://snowtooth.herokuapp.com/'</span>\n<span class=\"token parameter variable\">-H</span> <span class=\"token string\">'Content-Type: application/json'</span>\n<span class=\"token parameter variable\">--data</span> <span class=\"token string\">'{\"query\":\"mutation {setLiftStatus(id: \\\"panorama\\\" status: OPEN) {name status}}\"}'</span></code></pre></div>\n</li>\n<li><code class=\"language-text\">Subscription</code>: websocket을 통해 실시간 양방향 통신을 구현할 때 사용하는 방식</li>\n</ul>\n<br>\n<h3 id=\"grpcgoogle-remote-procedure-call\" style=\"position:relative;\"><a href=\"#grpcgoogle-remote-procedure-call\" aria-label=\"grpcgoogle remote procedure call permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC(Google Remote Procedure Call)</h3>\n<p>Google에서 개발한 <code class=\"language-text\">RPC(Remote Procedure Call)</code> 프레임워크이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAADCUlEQVQ4y22S2XLaShRF+f8PycOtyoNT5ha5sR2DSSzbmDAPAjSCwKAB0AAYSetWi8F2klM6pZbO7tVnd3du4EV0nJCWHdCwI5p2SNcJadsho2VEHMdZpkmC5W8zndA37JCmE9G2g0wvMti9kiubLteqzbXhku+aXMpTCopNUbe5VBzCfcIpmgufb8qCG92lMJzxpWOQV2xuNZv8yGboReRa8zXV6QpzFTFo/kLWDSr2htbM49rwCI7AFBh5IdXpMutGU4bI7SbVeUBttqJsOAegpE4pyiZ3sok0mnDVkLl4aCApFtfm8gwU0XnxuO0blAZjSj2Nsqzz+cczZdmkaLoHoCgUqh3yv/rkOzr5lso/t9JvwDQDtiyHfKVNodbnsqXyb8fg081P7noqpfEScR65hrD84jNY73ioN6loFtI8oj71+Ka75z0UyIEb8jxb0/K21EYaUrPDwyLi2VpS1I+Wq5bL3XDCsznnsT9CGhqUlCnVicOV7n2wLDsB5dEUSXvhaaDxKKuUlSlPpk3ROFqumAvyT00uHpt8H8342lb5ItV4Htt/HIro8Gu9z4VU47+uzvVgwudyhQfVomh6B8v12YqqsOGElOodJG3G/czPLF8Z3odrIzqsWEua7obHocGPzoCfs4Cq5VE0zpY97k2H+mRBo9ulOtS51Z3MckFzP1juOT73hk1l4tIaKjT6MiVtzuPY5Uazkd2I3MAN6Nk+PSeg9bKkvVhn477j01gEbOMU0lQ8jP0t3cVB21n4mb7nhMhCO/d5CXbkTldCxHa7Jd7vs3GSpsRJyj5JeI2Pmbx1K3RCD2+ENInJpdnq6RswjrPxLk6Ik9MdPOQujtnsD3WhOwOPDPHvA3C32xGFIeFmw2sGTknShDRNsrf4dqMdQRQRRVGm/yvwFKeC+LUVHb6riYj2CfZmf9a+jz86POV+v89WDjdbHD9ktgqwvDVjZ4Xp+oTRht1xa36fmwEF4JRJkrBarRgpClPLYjIZo2gaQ0VFN02syQRd11FVlfV6nenfzxf5PwQb99rURbIgAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-architecture-grpc.png\"\n        title=\"api-architecture-grpc.png\"\n        src=\"/static/12f523a3b7fbc2b7001cc28d5b84bbc0/37523/api-architecture-grpc.png\"\n        srcset=\"/static/12f523a3b7fbc2b7001cc28d5b84bbc0/e9ff0/api-architecture-grpc.png 180w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/f21e7/api-architecture-grpc.png 360w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/37523/api-architecture-grpc.png 720w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/302a4/api-architecture-grpc.png 1080w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/21335/api-architecture-grpc.png 1082w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Stub 컴파일러가 <code class=\"language-text\">IDL(Identity Definition Language)</code> 호출규약을 정의하고 파라미터를 <code class=\"language-text\">Marshalling</code>/<code class=\"language-text\">UnMarshalling</code> 처리하여 RPC 프로토콜로 전달</strong>한다. IDL에서 정의된 포맷에 따른 메세지를 주고받으며 단순히 <code class=\"language-text\">JSON</code>을 사용하는 것보다 일괄성 있게 데이터를 주고받을 수 있다.</p>\n<blockquote>\n<p><strong><em>Marshalling/UnMarshalling</em>:</strong> 데이터를 byte로 변환하고, 전송받은 byte 데이터를 복구하는 일련의 과정을 말한다. 데이터를 byte stream으로 변환하는 데이터와는 달리, 변환할 대상과 object가 한정되지 않는다는 특징이 있다.</p>\n</blockquote>\n<br>\n<p>주로 <code class=\"language-text\">Protobuf(Protocol buffers)</code>를 사용한다.</p>\n<blockquote>\n<p><strong><em>Proto Buffer</em>:</strong> 언어와 플랫폼에 관계없이 구조화된 데이터를 직렬화하기 위한 방법으로, 문자를 16진수로 인코딩하여 표현한다. 데이터의 크기가 작으며 parsing을 할 필요가 없으므로 통신이 빠르다. 반면, key-value쌍으로 손쉽게 작성할 수 있는 JSON 포맷과는 달리 별도의 문법을 사용해야 하며 16진수로 변환되기 때문에 직관적이지 않다는 단점이 있다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// protobuf.proto</span>\n\n<span class=\"token comment\">// syntax: 사용할 문법을 선언</span>\nsyntax <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">package</span> pkg_name<span class=\"token punctuation\">;</span>\noption go_package <span class=\"token operator\">=</span> <span class=\"token string\">\"pkg_path\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// service: 사용할 메소드를 선언 (stream을 사용해 통신방식을 일부 다르게 적용할 수 있음)</span>\nservice User <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// unary: 한 번의 호출에 대해 한 번 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// client-stream: 클라이언트에서 서버로 stream을 전달하고, 서버에서는 한 번 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>stream GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// server-stream: 클라이언트에서 한 번 전달, 서버에서는 stream으로 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>stream GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// bidirectional stream: 클라이언트와 서버 모두에서 stream으로 요청, 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>stream GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>stream GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// message: object 정의</span>\nmessage UserMessage <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> phone_number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int32</span> age <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nmessage GetUserRequest <span class=\"token punctuation\">{</span> <span class=\"token builtin\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\nmessage GetUserResponse <span class=\"token punctuation\">{</span> UserMessage user_message <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<p><code class=\"language-text\">gPRC</code>는 <code class=\"language-text\">HTTP/1.1</code>을 기반으로 하는 REST API와는 달리 <code class=\"language-text\">HTTP/2</code> 프로토콜을 사용한다. <code class=\"language-text\">HTTP/2.2</code> 기반으로 동작함에 따라 메세지를 binary 형태로 인코딩하여 주고받는다. 또한 하나의 TCP 연결에 대해 여러 개의 양방향 스트림(<code class=\"language-text\">bidirectional streams</code>)을 지원하는, blocking없이 여러 요청과 응답을 병렬적으로 수행할 수 있는 <code class=\"language-text\">Multiplexing</code> 개념이 적용되는 프레임워크이다.</p>\n<br>\n<h2 id=\"어떠한-api를-사용해야-하는-것일까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A0%ED%95%9C-api%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\" aria-label=\"어떠한 api를 사용해야 하는 것일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떠한 API를 사용해야 하는 것일까?</h2>\n<p>아래와 같은 요소들을 고려하여, 개발하고자 하는 서비스의 특성을 극대화할 수 있는 방법을 선택하면 된다.</p>\n<ul>\n<li><strong>데이터 포맷(Data Format)</strong>: REST의 JSON 포맷의 경우 접근성이 좋다는 장점이 있는 반면 일관성을 유지하기는 쉽지 않다는 단점이 있다. GraphQL 역시 기본적으로 JSON 포맷을 사용한다. gRPC의 protocol buffer의 경우, 구조화된 포맷을 적용할 수 있으며 언어에 구애받지 않는다는 장점이 있지만, human-readable하지는 않다는 단점도 있다.</li>\n<li><strong>데이터 가져오기(Data Fetching)</strong>: GraphQL의 경우 클라이언트가 필요로 하는 데이터만 요청하여 받아올 수 있으므로, fetching에 가장 용이하다. 반면 REST나 gRPC의 경우 서버에서 정의한 방식대로 데이터를 요청하고 응답받을 수 있으므로 over-fetching이나 under-fetching 문제가 발생할 수 있다.</li>\n<li><strong>브라우저 지원(Browser Support)</strong>: REST와 GraphQL의 경우, 모든 브라우저에서 지원이 가능하다. 반면, gRPC에 대한 브라우저 지원은 기본적으로 제공되지 않는다. 별도의 클라이언트를 구현해야 한다.</li>\n<li><strong>응답 시간(Response Time)</strong>: gRPC는 REST나 GraphQL에 비해 응답시간이 매우 빠르다. 또한 HTTP/2.0을 기반으로 동작하므로 지연 시간이 적고, 새로운 TCP 연결을 수립하지 않고도 여러 요청을 주고 받을 수 있어 성능적 측면에서 우수하다.</li>\n<li><strong>캐싱(Caching)</strong>: 요청과 응답에 대한 캐싱을 가장 쉽게 구현할 수 있는 방법은 REST이다. GET 요청에 대해 브라우저나 proxy server, CDN을 사용하여 손쉽게 캐싱을 적용할 수 있다. 반면 POST를 기본 method로 사용하는 GraphQL이나 기본적으로 캐싱을 제공하지 않아 별도의 middleware를 구현해야 하는 gRPC의 경우, 상대적으로 캐싱을 적용하기 위해 많은 비용이 소모된다.</li>\n</ul>\n<p>필요에 따라 여러 API 형식을 혼합하여 사용할 수도 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 718px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 122.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAAAPoAAAD6AG1e1JrAAADGUlEQVQ4y53LX2/aVhiAcb7pbtbcTLuY2i3rlGlXbbSKlhZGCA4FAnFIusbpoEAMOLYFbm0w/0owARs4xrh2TWyDcVIpN5kitiSgpFN39Fycc9735zidnthG72sba/x0ojlso3dhsbN0HjZ6e+PeK0uMT6WUwUfEamDSjVoyYQN42odtANty5sJizz4VTI2fw1o7+n1C8+fbtrhrDxCSDHzjy56LPh1kAfvc43ZeyH5bSsyWbaM3h8d8kONrQ0DOcKng+3F9a4bl+h8h369fwqOmFxSfKLVnZndn3N8bVp7y1KrOeXSQHR296NK/y5WnE/EGtgzJHtWuatczdz0XRpYhOS7mz/n5+eTfYxhGt9u9etq2vbDsMCe2pI1vTZA+FWvcwidQ9A742AGybloOoJrVwfRmCXYQJkGYBJ6/yr+4dwO5TpgEQbxbFPTqYFoGE6qlUC21OxzdguPsMESpIUq9/yy27NlzJ5shSn2Zlxn+5OYaUM0vYS/aWYGSAXL4Ffh954Q4UogjhWwqaaY9uxNHSkW0/htfVe6bRIW/a3qNEboPF0S4IEbILoRygWxrKw8glHO/YbfyYCPDQSgXIXsvc8cQym0SAtFUrnE4x33nfBWi1JVYdQlilvz0bzBzz88sbZRWtujLC1R8GGW+9VFLG6XlaAlrfLzGO+9EP9YPUaofH7jSwosDYYMYOBMtZ6IF4eLzNO9KCxAhuVHBlRbWD8U5nCxLCDPXbkGIZD8E05VorrEwQhipcKxd4tOzz/rYujVF07k2f9f09Oyz42Soyg3+ro7fVxd+xFqrglN1kh72RMdIlLW60EwW6gjRQIjaa4yBU6XYQQPBGTiFrsUaCF7cPmDgVP31IRtDGThV+xPrF2ojUf4H4/t55w7W3MYOV6PxHzxv73tzT6LZZSj7E5RZ3cR+DqQerGUfbWIPA+kHPuJxVCDK17ixh78LxpvbWDWUpr0I7duvR1DcFcNdMTaUpNf2aS9SDR/Q629oL1IJpuYwj7PtDH2zY5SuxvFqHG8k8wujdoaWmOYlnujmCMj/o4lu/g0tFaTaBy0DNwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-architecture-choose.png\"\n        title=\"api-architecture-choose.png\"\n        src=\"/static/f0b3176a071fcdfaac563f40b48cc907/57dc1/api-architecture-choose.png\"\n        srcset=\"/static/f0b3176a071fcdfaac563f40b48cc907/e9ff0/api-architecture-choose.png 180w,\n/static/f0b3176a071fcdfaac563f40b48cc907/f21e7/api-architecture-choose.png 360w,\n/static/f0b3176a071fcdfaac563f40b48cc907/57dc1/api-architecture-choose.png 718w\"\n        sizes=\"(max-width: 718px) 100vw, 718px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<ul>\n<li><a href=\"https://www.baeldung.com/rest-vs-graphql-vs-grpc\">https://www.baeldung.com/rest-vs-graphql-vs-grpc</a></li>\n<li><a href=\"https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/\">https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/</a></li>\n<li><a href=\"https://code.tutsplus.com/tutorials/rest-vs-grpc-battle-of-the-apis--cms-30711\">https://code.tutsplus.com/tutorials/rest-vs-grpc-battle-of-the-apis—cms-30711</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#api%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C\">API는 어떤 방식으로 동작할까?</a></p>\n<ul>\n<li><a href=\"#%EC%9E%90%EC%9B%90resource\">자원(resource)</a></li>\n<li><a href=\"#%EB%8F%99%EC%9E%91method\">동작(method)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#api%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\">API의 종류에 대해 알아보자</a></p>\n<ul>\n<li><a href=\"#restrepresential-state-transfer\">REST(REpresential State Transfer)</a></li>\n<li><a href=\"#graphql\">GraphQL</a></li>\n<li><a href=\"#grpcgoogle-remote-procedure-call\">gRPC(Google Remote Procedure Call)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%96%B4%EB%96%A0%ED%95%9C-api%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\">어떠한 API를 사용해야 하는 것일까?</a></p>\n<ul>\n<li><a href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 01, 2023","title":"어떤 API를 사용해야 할까? - REST, GraphQL, 그리고 GRPC","categories":"웹","author":"소희","emoji":"🐤"},"fields":{"slug":"/api-architecture/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://soheeeep.github.io","comments":{"utterances":{"repo":"https://github.com/soheeeeP/soheeeep.github.io"}}}}},"pageContext":{"slug":"/web-http/","nextSlug":"/api-architecture/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
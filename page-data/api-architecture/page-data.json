{"componentChunkName":"component---src-templates-blog-template-js","path":"/api-architecture/","result":{"data":{"cur":{"id":"36b6c771-3e4a-5b9a-8aed-913d8230f89f","html":"<p><code class=\"language-text\">API(Application Programming Interface)</code>는 <strong>서비스와 서비스끼리 통신하기 위해, 즉 요청과 응답을 주고받기 위해 정의된 다양한 종류의 인터페이스</strong>이다. ‘다양한 서비스가 만나는 지점’이자 ‘서비스의 동작을 정의한 일종의 약속’이라고도 표현할 수 있을 것 같다. 실제 서비스를 제공하기 위해서는 무수히 많은 소프트웨어 서비스가 맞물려서 운영되어야 하기 때문에, 구체적이고 확장성이 높은 API를 정의하는 것은 매우 중요하다.</p>\n<br>\n<h2 id=\"api는-어떤-방식으로-동작할까\" style=\"position:relative;\"><a href=\"#api%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C\" aria-label=\"api는 어떤 방식으로 동작할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API는 어떤 방식으로 동작할까?</h2>\n<p>API는 클라이언트와 서버 사이에서 요청과 응답을 통해 리소스를 주고받는 방식으로 동작한다.<br>\nAPI를 구성하는 요소들은 아래와 같다.</p>\n<h3 id=\"자원resource\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%9B%90resource\" aria-label=\"자원resource permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자원(resource)</h3>\n<p>‘이 리소스를 어떻게 명확하게 표현할 수 있을지?‘가 바로 API가 풀어내야 할 과제가 된다. 여기서 <strong>리소스는 DB에 저장된 데이터 자체가 아닌, 데이터의 상태를 클라이언트가 요청한 방식에 맞추어 표현하여 전달한 응답</strong>이다. 리소스는 JSON 데이터일수도, 이미지일수도 또는 어떠한 문서일수도 있다.</p>\n<h3 id=\"동작method\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91method\" aria-label=\"동작method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작(method)</h3>\n<p>또한 리소스에 대해 <strong>어떤 동작을 수행할 것인지를</strong> 정의한다. 리소스를 생성(<code class=\"language-text\">POST</code>)할 것인지, 단순히 가져올 것인지(<code class=\"language-text\">GET</code>)와 같은 행위를 명시해야 한다.</p>\n<br>\n<h2 id=\"api의-종류에-대해-알아보자\" style=\"position:relative;\"><a href=\"#api%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" aria-label=\"api의 종류에 대해 알아보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>API의 종류에 대해 알아보자</h2>\n<p>API의 형식은 게속해서 발전하여 왔다. 그 중 가장 보편화된 3가지 방식에 대해 설명해보려 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtUlEQVQoz2WQW2/aQBBGxzZgcNiLL7sLGLC99oJh7bUhSCStmpKkD22TVJX62Pal//9HVA5pVLXSeZj5RmdGGnDC9eH0tb7+rK8+fvr2S+0/3D39zMwJkLSDteWv/sf+U0AvKpu3j8vqJjOnu8cfu3dfbh++y+b2LANV/8pUASleZKDKwTmKWxhLGC5hnHmi6oUlUGUH6yA9/H0fqOpHG7zYddOz7E2qRN9Y/soJSyAqrd/jeQtIonmr9vfetAbych9IEWQHaU7O80YAUvSjki53QAqgCqgKkssB2wCWFzMjiuOAb19HQAqy3M1W105UduEFrya8iVk7ENuxqJhoBDMRM4Fo+mw7Cc2YVZTXrtBDoV2hR0zHUeNz44kKKK+nrEG8crn2uJ4wQ3jNuAmYcYX2edfGvB1w7T4zEpqyOmbtiGtw+QbHBrAEkvd8JeQBUDqe1XTZdiGWLivDZA8oA5KfsWgeppfdw8i8nq+PFs4AZ2hWJds3PT/3FyZM2k5AKZ3X8fpoEfmKTeSivOqHCkZsRWJt4RRQ0tUz7VA5jNQwUoASQMkwUmiysUlm4fSMjVM87ZLfnJg8qhsksSIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-architecture-timeline.png\"\n        title=\"api-architecture-timeline.png\"\n        src=\"/static/55ea0de85b54807e674dddd161c9c12e/37523/api-architecture-timeline.png\"\n        srcset=\"/static/55ea0de85b54807e674dddd161c9c12e/e9ff0/api-architecture-timeline.png 180w,\n/static/55ea0de85b54807e674dddd161c9c12e/f21e7/api-architecture-timeline.png 360w,\n/static/55ea0de85b54807e674dddd161c9c12e/37523/api-architecture-timeline.png 720w,\n/static/55ea0de85b54807e674dddd161c9c12e/b4098/api-architecture-timeline.png 816w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<h3 id=\"restrepresential-state-transfer\" style=\"position:relative;\"><a href=\"#restrepresential-state-transfer\" aria-label=\"restrepresential state transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST(REpresential State Transfer)</h3>\n<p><code class=\"language-text\">REST(REpresential State Transfer)</code>는 HTTP 프로토콜 위에서 동작하는, 가장 보편적으로 쓰이는 API 형식이다. URL과 HTTP method(<code class=\"language-text\">GET</code>, <code class=\"language-text\">POST</code>, <code class=\"language-text\">PATCH</code>, <code class=\"language-text\">DELETE</code>)를 사용하여 리소스에 접근한다.</p>\n<p><code class=\"language-text\">REST</code>는 <strong>stateless</strong>한 특징을 가지며 <strong>caching</strong>을 적용하여 클라이언트와 서버가 지속적으로 연결을 수립할 필요가 없게 구현할 수 있다. 또한 다양한 프로그래밍 언어로 구현할 수 있고, 일반 텍스트, <code class=\"language-text\">HTML</code>, <code class=\"language-text\">YAML</code>, <code class=\"language-text\">XML</code>, <code class=\"language-text\">JSON</code>과 같이 <strong>다양한 포맷으로 리소스를 주고받을 수 있다</strong>는 장점이 있다. 주로 JSON 포맷으로 데이터를 주고 받는다.</p>\n<p>반면, <text style=\"color:#000066;\"><strong>클라이언트는 언제나 요청된 endpoint에서 정의된 리소스만 받아올 수 있다는 단점도 있다.</strong></text>\n한 번의 요청에 불필요한 리소스까지 모두 포함되거나(over-fetching), 클라이언트가 필요로 하는 데이터를 얻기 위해서는 여러 번의 서로 다른 요청(under-fetching)을 보내게 될 수 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># curL을 사용한 REST API 요청</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-i</span> <span class=\"token parameter variable\">-X</span> GET http://localhost:8080/api/books</code></pre></div>\n<br>\n<h3 id=\"graphql\" style=\"position:relative;\"><a href=\"#graphql\" aria-label=\"graphql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL</h3>\n<p>Facebook에서 개발한 API를 위한 query 언어이다.\nREST API와 달리 리소스에 대한 별도의 endpoint가 존재하지 않고, <strong>하나의 endpoint만 존재</strong>한다.</p>\n<p>필요한 컬럼에 대해서만 선택적으로 요청을 보낼 수 있어 클라이언트가 필요로 하는 데이터만 받을 수 있다는 것이 가장 큰 장점이다. 여러 depth로 구성된 데이터에 접근하는 경우에도, 요청을 여러 번 보내지 않고 효율적으로 리소스를 주고 받을 수 있다. <em><strong>즉, 사용자는 한 번의 요청만으로 원하는 데이터를 전부 응답받을 수 있다.</strong></em></p>\n<p>또한 HTTP Method에 따라 리소스에 대한 접근 방식이 달랐던 REST API는 달리 <code class=\"language-text\">POST</code> method만을 사용하여 <code class=\"language-text\">Query</code>, <code class=\"language-text\">Mutation</code>, <code class=\"language-text\">Subscription</code> 3가지 방식으로 동작한다.</p>\n<ul>\n<li><code class=\"language-text\">Query</code>: 데이터를 요청할 때 사용하는 방식\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># curL을 사용한 GraphQL query 요청</span>\n<span class=\"token function\">curl</span>  <span class=\"token string\">'http://snowtooth.herokuapp.com/'</span>\n<span class=\"token parameter variable\">-H</span> <span class=\"token string\">'Content-Type: application/json'</span>\n<span class=\"token parameter variable\">--data</span> <span class=\"token string\">'{\"query\":\"{ query { books {id, name}}}\"}'</span></code></pre></div>\n</li>\n<li><code class=\"language-text\">Mutation</code>: 데이터를 조작할 때(<code class=\"language-text\">INSERT</code>, <code class=\"language-text\">UPDATE</code>, <code class=\"language-text\">DELETE</code>) 사용하는 방식\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token string\">'http://snowtooth.herokuapp.com/'</span>\n<span class=\"token parameter variable\">-H</span> <span class=\"token string\">'Content-Type: application/json'</span>\n<span class=\"token parameter variable\">--data</span> <span class=\"token string\">'{\"query\":\"mutation {setLiftStatus(id: \\\"panorama\\\" status: OPEN) {name status}}\"}'</span></code></pre></div>\n</li>\n<li><code class=\"language-text\">Subscription</code>: websocket을 통해 실시간 양방향 통신을 구현할 때 사용하는 방식</li>\n</ul>\n<br>\n<h3 id=\"grpcgoogle-remote-procedure-call\" style=\"position:relative;\"><a href=\"#grpcgoogle-remote-procedure-call\" aria-label=\"grpcgoogle remote procedure call permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC(Google Remote Procedure Call)</h3>\n<p>Google에서 개발한 <code class=\"language-text\">RPC(Remote Procedure Call)</code> 프레임워크이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAADCUlEQVQ4y22S2XLaShRF+f8PycOtyoNT5ha5sR2DSSzbmDAPAjSCwKAB0AAYSetWi8F2klM6pZbO7tVnd3du4EV0nJCWHdCwI5p2SNcJadsho2VEHMdZpkmC5W8zndA37JCmE9G2g0wvMti9kiubLteqzbXhku+aXMpTCopNUbe5VBzCfcIpmgufb8qCG92lMJzxpWOQV2xuNZv8yGboReRa8zXV6QpzFTFo/kLWDSr2htbM49rwCI7AFBh5IdXpMutGU4bI7SbVeUBttqJsOAegpE4pyiZ3sok0mnDVkLl4aCApFtfm8gwU0XnxuO0blAZjSj2Nsqzz+cczZdmkaLoHoCgUqh3yv/rkOzr5lso/t9JvwDQDtiyHfKVNodbnsqXyb8fg081P7noqpfEScR65hrD84jNY73ioN6loFtI8oj71+Ka75z0UyIEb8jxb0/K21EYaUrPDwyLi2VpS1I+Wq5bL3XDCsznnsT9CGhqUlCnVicOV7n2wLDsB5dEUSXvhaaDxKKuUlSlPpk3ROFqumAvyT00uHpt8H8342lb5ItV4Htt/HIro8Gu9z4VU47+uzvVgwudyhQfVomh6B8v12YqqsOGElOodJG3G/czPLF8Z3odrIzqsWEua7obHocGPzoCfs4Cq5VE0zpY97k2H+mRBo9ulOtS51Z3MckFzP1juOT73hk1l4tIaKjT6MiVtzuPY5Uazkd2I3MAN6Nk+PSeg9bKkvVhn477j01gEbOMU0lQ8jP0t3cVB21n4mb7nhMhCO/d5CXbkTldCxHa7Jd7vs3GSpsRJyj5JeI2Pmbx1K3RCD2+ENInJpdnq6RswjrPxLk6Ik9MdPOQujtnsD3WhOwOPDPHvA3C32xGFIeFmw2sGTknShDRNsrf4dqMdQRQRRVGm/yvwFKeC+LUVHb6riYj2CfZmf9a+jz86POV+v89WDjdbHD9ktgqwvDVjZ4Xp+oTRht1xa36fmwEF4JRJkrBarRgpClPLYjIZo2gaQ0VFN02syQRd11FVlfV6nenfzxf5PwQb99rURbIgAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-architecture-grpc.png\"\n        title=\"api-architecture-grpc.png\"\n        src=\"/static/12f523a3b7fbc2b7001cc28d5b84bbc0/37523/api-architecture-grpc.png\"\n        srcset=\"/static/12f523a3b7fbc2b7001cc28d5b84bbc0/e9ff0/api-architecture-grpc.png 180w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/f21e7/api-architecture-grpc.png 360w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/37523/api-architecture-grpc.png 720w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/302a4/api-architecture-grpc.png 1080w,\n/static/12f523a3b7fbc2b7001cc28d5b84bbc0/21335/api-architecture-grpc.png 1082w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Stub 컴파일러가 <code class=\"language-text\">IDL(Identity Definition Language)</code> 호출규약을 정의하고 파라미터를 <code class=\"language-text\">Marshalling</code>/<code class=\"language-text\">UnMarshalling</code> 처리하여 RPC 프로토콜로 전달</strong>한다. IDL에서 정의된 포맷에 따른 메세지를 주고받으며 단순히 <code class=\"language-text\">JSON</code>을 사용하는 것보다 일괄성 있게 데이터를 주고받을 수 있다.</p>\n<blockquote>\n<p><strong><em>Marshalling/UnMarshalling</em>:</strong> 데이터를 byte로 변환하고, 전송받은 byte 데이터를 복구하는 일련의 과정을 말한다. 데이터를 byte stream으로 변환하는 데이터와는 달리, 변환할 대상과 object가 한정되지 않는다는 특징이 있다.</p>\n</blockquote>\n<br>\n<p>주로 <code class=\"language-text\">Protobuf(Protocol buffers)</code>를 사용한다.</p>\n<blockquote>\n<p><strong><em>Proto Buffer</em>:</strong> 언어와 플랫폼에 관계없이 구조화된 데이터를 직렬화하기 위한 방법으로, 문자를 16진수로 인코딩하여 표현한다. 데이터의 크기가 작으며 parsing을 할 필요가 없으므로 통신이 빠르다. 반면, key-value쌍으로 손쉽게 작성할 수 있는 JSON 포맷과는 달리 별도의 문법을 사용해야 하며 16진수로 변환되기 때문에 직관적이지 않다는 단점이 있다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// protobuf.proto</span>\n\n<span class=\"token comment\">// syntax: 사용할 문법을 선언</span>\nsyntax <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">package</span> pkg_name<span class=\"token punctuation\">;</span>\noption go_package <span class=\"token operator\">=</span> <span class=\"token string\">\"pkg_path\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// service: 사용할 메소드를 선언 (stream을 사용해 통신방식을 일부 다르게 적용할 수 있음)</span>\nservice User <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// unary: 한 번의 호출에 대해 한 번 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// client-stream: 클라이언트에서 서버로 stream을 전달하고, 서버에서는 한 번 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>stream GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// server-stream: 클라이언트에서 한 번 전달, 서버에서는 stream으로 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>stream GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// bidirectional stream: 클라이언트와 서버 모두에서 stream으로 요청, 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>stream GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>stream GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// message: object 정의</span>\nmessage UserMessage <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> phone_number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int32</span> age <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nmessage GetUserRequest <span class=\"token punctuation\">{</span> <span class=\"token builtin\">string</span> user_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\nmessage GetUserResponse <span class=\"token punctuation\">{</span> UserMessage user_message <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<p><code class=\"language-text\">gPRC</code>는 <code class=\"language-text\">HTTP/1.1</code>을 기반으로 하는 REST API와는 달리 <code class=\"language-text\">HTTP/2</code> 프로토콜을 사용한다. <code class=\"language-text\">HTTP/2.2</code> 기반으로 동작함에 따라 메세지를 binary 형태로 인코딩하여 주고받는다. 또한 하나의 TCP 연결에 대해 여러 개의 양방향 스트림(<code class=\"language-text\">bidirectional streams</code>)을 지원하는, blocking없이 여러 요청과 응답을 병렬적으로 수행할 수 있는 <code class=\"language-text\">Multiplexing</code> 개념이 적용되는 프레임워크이다.</p>\n<br>\n<h2 id=\"어떠한-api를-사용해야-하는-것일까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A0%ED%95%9C-api%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\" aria-label=\"어떠한 api를 사용해야 하는 것일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떠한 API를 사용해야 하는 것일까?</h2>\n<p>아래와 같은 요소들을 고려하여, 개발하고자 하는 서비스의 특성을 극대화할 수 있는 방법을 선택하면 된다.</p>\n<ul>\n<li><strong>데이터 포맷(Data Format)</strong>: REST의 JSON 포맷의 경우 접근성이 좋다는 장점이 있는 반면 일관성을 유지하기는 쉽지 않다는 단점이 있다. GraphQL 역시 기본적으로 JSON 포맷을 사용한다. gRPC의 protocol buffer의 경우, 구조화된 포맷을 적용할 수 있으며 언어에 구애받지 않는다는 장점이 있지만, human-readable하지는 않다는 단점도 있다.</li>\n<li><strong>데이터 가져오기(Data Fetching)</strong>: GraphQL의 경우 클라이언트가 필요로 하는 데이터만 요청하여 받아올 수 있으므로, fetching에 가장 용이하다. 반면 REST나 gRPC의 경우 서버에서 정의한 방식대로 데이터를 요청하고 응답받을 수 있으므로 over-fetching이나 under-fetching 문제가 발생할 수 있다.</li>\n<li><strong>브라우저 지원(Browser Support)</strong>: REST와 GraphQL의 경우, 모든 브라우저에서 지원이 가능하다. 반면, gRPC에 대한 브라우저 지원은 기본적으로 제공되지 않는다. 별도의 클라이언트를 구현해야 한다.</li>\n<li><strong>응답 시간(Response Time)</strong>: gRPC는 REST나 GraphQL에 비해 응답시간이 매우 빠르다. 또한 HTTP/2.0을 기반으로 동작하므로 지연 시간이 적고, 새로운 TCP 연결을 수립하지 않고도 여러 요청을 주고 받을 수 있어 성능적 측면에서 우수하다.</li>\n<li><strong>캐싱(Caching)</strong>: 요청과 응답에 대한 캐싱을 가장 쉽게 구현할 수 있는 방법은 REST이다. GET 요청에 대해 브라우저나 proxy server, CDN을 사용하여 손쉽게 캐싱을 적용할 수 있다. 반면 POST를 기본 method로 사용하는 GraphQL이나 기본적으로 캐싱을 제공하지 않아 별도의 middleware를 구현해야 하는 gRPC의 경우, 상대적으로 캐싱을 적용하기 위해 많은 비용이 소모된다.</li>\n</ul>\n<p>필요에 따라 여러 API 형식을 혼합하여 사용할 수도 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 718px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 122.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAAAPoAAAD6AG1e1JrAAADGUlEQVQ4y53LX2/aVhiAcb7pbtbcTLuY2i3rlGlXbbSKlhZGCA4FAnFIusbpoEAMOLYFbm0w/0owARs4xrh2TWyDcVIpN5kitiSgpFN39Fycc9735zidnthG72sba/x0ojlso3dhsbN0HjZ6e+PeK0uMT6WUwUfEamDSjVoyYQN42odtANty5sJizz4VTI2fw1o7+n1C8+fbtrhrDxCSDHzjy56LPh1kAfvc43ZeyH5bSsyWbaM3h8d8kONrQ0DOcKng+3F9a4bl+h8h369fwqOmFxSfKLVnZndn3N8bVp7y1KrOeXSQHR296NK/y5WnE/EGtgzJHtWuatczdz0XRpYhOS7mz/n5+eTfYxhGt9u9etq2vbDsMCe2pI1vTZA+FWvcwidQ9A742AGybloOoJrVwfRmCXYQJkGYBJ6/yr+4dwO5TpgEQbxbFPTqYFoGE6qlUC21OxzdguPsMESpIUq9/yy27NlzJ5shSn2Zlxn+5OYaUM0vYS/aWYGSAXL4Ffh954Q4UogjhWwqaaY9uxNHSkW0/htfVe6bRIW/a3qNEboPF0S4IEbILoRygWxrKw8glHO/YbfyYCPDQSgXIXsvc8cQym0SAtFUrnE4x33nfBWi1JVYdQlilvz0bzBzz88sbZRWtujLC1R8GGW+9VFLG6XlaAlrfLzGO+9EP9YPUaofH7jSwosDYYMYOBMtZ6IF4eLzNO9KCxAhuVHBlRbWD8U5nCxLCDPXbkGIZD8E05VorrEwQhipcKxd4tOzz/rYujVF07k2f9f09Oyz42Soyg3+ro7fVxd+xFqrglN1kh72RMdIlLW60EwW6gjRQIjaa4yBU6XYQQPBGTiFrsUaCF7cPmDgVP31IRtDGThV+xPrF2ojUf4H4/t55w7W3MYOV6PxHzxv73tzT6LZZSj7E5RZ3cR+DqQerGUfbWIPA+kHPuJxVCDK17ixh78LxpvbWDWUpr0I7duvR1DcFcNdMTaUpNf2aS9SDR/Q629oL1IJpuYwj7PtDH2zY5SuxvFqHG8k8wujdoaWmOYlnujmCMj/o4lu/g0tFaTaBy0DNwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-architecture-choose.png\"\n        title=\"api-architecture-choose.png\"\n        src=\"/static/f0b3176a071fcdfaac563f40b48cc907/57dc1/api-architecture-choose.png\"\n        srcset=\"/static/f0b3176a071fcdfaac563f40b48cc907/e9ff0/api-architecture-choose.png 180w,\n/static/f0b3176a071fcdfaac563f40b48cc907/f21e7/api-architecture-choose.png 360w,\n/static/f0b3176a071fcdfaac563f40b48cc907/57dc1/api-architecture-choose.png 718w\"\n        sizes=\"(max-width: 718px) 100vw, 718px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<br></p>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://www.baeldung.com/rest-vs-graphql-vs-grpc\">https://www.baeldung.com/rest-vs-graphql-vs-grpc</a></li>\n<li><a href=\"https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/\">https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/</a></li>\n<li><a href=\"https://code.tutsplus.com/tutorials/rest-vs-grpc-battle-of-the-apis--cms-30711\">https://code.tutsplus.com/tutorials/rest-vs-grpc-battle-of-the-apis—cms-30711</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#api%EB%8A%94-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C\">API는 어떤 방식으로 동작할까?</a></p>\n<ul>\n<li><a href=\"#%EC%9E%90%EC%9B%90resource\">자원(resource)</a></li>\n<li><a href=\"#%EB%8F%99%EC%9E%91method\">동작(method)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#api%EC%9D%98-%EC%A2%85%EB%A5%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\">API의 종류에 대해 알아보자</a></p>\n<ul>\n<li><a href=\"#restrepresential-state-transfer\">REST(REpresential State Transfer)</a></li>\n<li><a href=\"#graphql\">GraphQL</a></li>\n<li><a href=\"#grpcgoogle-remote-procedure-call\">gRPC(Google Remote Procedure Call)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%96%B4%EB%96%A0%ED%95%9C-api%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\">어떠한 API를 사용해야 하는 것일까?</a></p>\n</li>\n<li>\n<p><a href=\"#references\">References</a></p>\n</li>\n</ul>\n</div>","excerpt":"는 서비스와 서비스끼리 통신하기 위해, 즉 요청과 응답을 주고받기 위해 정의된 다양한 종류의 인터페이스이다. ‘다양한 서비스가 만나는 지점’이자 ‘서비스의 동작을 정의한 일종의 약속’이라고도 표현할 수 있을 것 같다. 실제 서비스를 제공하기 위해서는 무수히 많은 소프트웨어 서비스가 맞물려서 운영되어야 하기 때문에, 구체적이고 확장성이 높은 API를 정의하는 것은 매우 중요하다. API는 어떤 방식으로 동작할까? API는 클라이언트와 서버 사이에서 요청과 응답을 통해 리소스를 주고받는 방식으로 동작한다. API를 구성하는 요소들은 아래와 같다. 자원(resource) ‘이 리소스를 어떻게 명확하게 표현할 수 있을지?‘가 바로 API가 풀어내야 할 과제가 된다. 여기서 리소스는 DB에 저장된 데이터 자체가 아닌, 데이터의 상태를 클라이언트가 요청한 방식에 맞추어 표현하여 전달한 응답이다. 리소스는 JSON 데이터일수도, 이미지일수도 또는 어떠한 문서일수도 있다. 동작(method) 또…","frontmatter":{"date":"June 01, 2023","title":"어떤 API를 사용해야 할까? - REST, GraphQL, 그리고 GRPC","categories":"웹","author":"소희","emoji":"🐤"},"fields":{"slug":"/api-architecture/"}},"next":{"id":"9c38cc4c-2b93-5988-9a44-96136daea0e6","html":"<h2 id=\"비동기-프로그래밍과-동작원리\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"비동기 프로그래밍과 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 프로그래밍과 동작원리</h2>\n<p><strong>비동기(asynchronous)</strong> 처리는 현재 실행 중인 작업이 완료되지 않은 상태에서 다른 작업을 처리하도록 요청할 수 있는 방식이다. <strong>동기(synchronous)</strong> 처리와 다르게 여러 작업을 동시에 실행할 수 있다는 장점이 있다.</p>\n<p>파이선에서는 비동기 프로그래밍을 적용하여 동시성을 보장하기 위해 <code class=\"language-text\">asyncio</code>라는 모듈을 사용한다.</p>\n<br>\n<h2 id=\"coroutine코루틴\" style=\"position:relative;\"><a href=\"#coroutine%EC%BD%94%EB%A3%A8%ED%8B%B4\" aria-label=\"coroutine코루틴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Coroutine(코루틴)</h2>\n<p>특정 함수를 실행할 때, 반복되는 작업을 개별 함수로 분리하고 이를 호출하여 사용할 수 있다. 여기서 호출되어 수행되는 흐름을 <code class=\"language-text\">Sub Routine</code>이라고 한다. <code class=\"language-text\">Sub Routine</code>은 하나의 entry point를 가지고 있으며 호출되는 <code class=\"language-text\">Main Routine</code>에 종속적이라는 특징을 가지고 있다.</p>\n<p><code class=\"language-text\">Coroutine</code>이란 서브 루틴처럼 특정 함수의 실행에 종속되어 있는 것이 아닌, 대등한 관계를 가지고 서로 순차적으로 호출할 수 있도록 구현된 함수라고 할 수 있다. <code class=\"language-text\">Sub Routine</code>과 달리 여러 개의 entry point와 exit point를 가진다.\n<code class=\"language-text\">Coroutine</code>을 이해하기 위해 아래 개념들을 알 필요가 있다.</p>\n<br>\n<h3 id=\"iterator이터레이터\" style=\"position:relative;\"><a href=\"#iterator%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"iterator이터레이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Iterator(이터레이터)</h3>\n<p>순서대로 값을 리턴할 수 있는 객체이다. 필요한 값을 메모리에 할당하고, 반환하도록 동작하여 메모리를 효율적으로 사용할 수 있다. <code class=\"language-text\">iter(object)</code> 또는 <code class=\"language-text\">object.__iter__()</code>를 사용하여 정의할 수 있고, <code class=\"language-text\">object.__next__()</code> 메소드를 호출하여 객체를 호출될 때마다 다음 값을 리턴하게 구현할 수 있다. 또한 특정 object에 <code class=\"language-text\">iter()</code>함수를 사용할 때마다 새로운 <code class=\"language-text\">Iterator</code> 객체가 생성되고, 각각의 객체들은 서로 독립적인 상태를 가지게 된다.<br>\n이러한 특성을 활용하여 <b>필요한 시점에 객체를 호출하여 여러 작업을 번갈아가면서 수행</b>하도록 구현할 수 있다.\n가장 간단하게 for문으로 수행하는 파이선의 <code class=\"language-text\">range()</code> 함수를 예로 들 수 있다. iteratable한 객체, 즉 반복이 가능한 객체를 메모리에 할당하지 않고 순차적으로 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 0 ~ 99의 integer를 별도의 메모리 공간에 할당해두지 않고, iteration이 될 때마다 꺼내어서 사용</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> \n    <span class=\"token builtin\">sum</span> <span class=\"token operator\">+=</span> i</code></pre></div>\n<br>\n<h3 id=\"generator제너레이터\" style=\"position:relative;\"><a href=\"#generator%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"generator제너레이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generator(제너레이터)</h3>\n<p><code class=\"language-text\">__iter__()</code>를 사용하지 않고도 <code class=\"language-text\">Iterator</code> 객체를 생성할 수 있다. 가장 큰 차이는 <code class=\"language-text\">yield</code>를 사용하여 중단점을 설정하고 작업을 재개할 수 있도록 구현되었다는 점이다. <code class=\"language-text\">generator</code> 객체를 생성한 뒤 <code class=\"language-text\">next(object)</code>를 호출해야 작업이 시작되며, 실행 시마다 값을 메모리에 할당하여 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">generator</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">yield</span> i</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">print<span class=\"token punctuation\">(</span>generator<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span>, <span class=\"token number\">2</span>, <span class=\"token number\">3</span>, <span class=\"token number\">4</span>, <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">))</span>       <span class=\"token comment\"># 값들이 메모리에 적재되어 있지 않고, 객체만 생성된 상태</span>\n<span class=\"token operator\">>></span> <span class=\"token operator\">&lt;</span>generator object generator at 0x00E3556<span class=\"token operator\"><span class=\"token file-descriptor important\">8</span>></span></code></pre></div>\n<br>\n<p><code class=\"language-text\">generator</code>를 호출하는 함수를 <code class=\"language-text\">caller</code>라고 하자.\n<code class=\"language-text\">caller</code>에서 <code class=\"language-text\">next(object)</code>를 호출하면 제어권이 <code class=\"language-text\">generator</code>로 전달되고, 로직에 따라 작업을 수행한다. <code class=\"language-text\">yield</code> 구문을 만나면, 실행 결과를 저장하고 다시 caller쪽으로 제어권을 반환한다. <code class=\"language-text\">caller</code>가 <code class=\"language-text\">generator</code>로 값을 전달할 때는 <code class=\"language-text\">object.send(value)</code> 함수를 사용하면 된다. (아직 시작이 되지 않은 generator에는 <code class=\"language-text\">None</code>값만 전달할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">generator_coroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'callee 1'</span><span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'callee 2: %d'</span> <span class=\"token operator\">%</span> x<span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token number\">2</span>\n\t\ntask <span class=\"token operator\">=</span> generator_coroutine<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ni <span class=\"token operator\">=</span> <span class=\"token builtin\">next</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span>    <span class=\"token comment\"># i = 1 / caller 1 출력</span>\ni <span class=\"token operator\">=</span> task<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># i = 2 / caller 2: 10 출력</span></code></pre></div>\n<br>\n<p>두 개 이상의 <code class=\"language-text\">Generator</code>가 서로 값을 주고받으면서 교차적으로 수행할 수 있어서 <code class=\"language-text\">lightweight coroutine</code>이라고 표현하기도 한다. 하나의 thread 위에서 여러 실행 흐름이 존재할 수 있도록 구현함으로서 작업들이 동시에 진행되는 것처럼 처리할 수 있다.</p>\n<p><code class=\"language-text\">yield from</code> 구문을 사용하여 <code class=\"language-text\">Coroutine</code> 내부에서 <code class=\"language-text\">Sub Coroutine</code>을 사용하도록 구현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">generator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">yield</span> <span class=\"token keyword\">from</span> generator_2<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">yield</span> <span class=\"token keyword\">from</span> generator_3<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br>\n<blockquote>\n<p><strong><em>NOTE:</em></strong> 파이선에서는 <code class=\"language-text\">yield</code>를 사용하는 <code class=\"language-text\">coroutine</code>을 <code class=\"language-text\">Generator-based coroutine</code>이라고 부르고, <code class=\"language-text\">asyncio</code> 모듈에서 지원하는 <code class=\"language-text\">async/await</code> 키워드를 사용하여 <code class=\"language-text\">coroutine</code>을 정의하는 방식을 <code class=\"language-text\">Native coroutine</code>이라고 부른다.</p>\n</blockquote>\n<br>\n<h2 id=\"event-loop\" style=\"position:relative;\"><a href=\"#event-loop\" aria-label=\"event loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Event Loop</h2>\n<p>파이선 <code class=\"language-text\">asyncio</code>에서는 <code class=\"language-text\">coroutine</code>과 <code class=\"language-text\">event loop</code>를 사용하여 비동기 프로그래밍을 지원한다.</p>\n<p><code class=\"language-text\">coroutine</code> 객체가 생성 및 반환 후에 <code class=\"language-text\">coroutine</code>을 실행해주는 부분이 선언되어 있어야 작업(task)이 개시된다. 여기서 사용되는 개념이 바로 event loop이다. event loop는 하나의 thread에서 등록된 여러 코루틴 사이의 실행권을 가지고 연산을 수행시키는 역할을 한다.\n쉽개 말하면, 무한히 loop를 돌며, loop마다 작업(task)을 하나씩 실행시키는 일종의 로직이다. thread에 event loop를 설정한다는 것은 **“작업, 즉 하나의 coroutine에서 출발하는 하나의 실행 흐름을 수행할 수 로직을 실행할 객체를 생성한 것”**이라고 이해하면 된다.</p>\n<p>이 때 전달받은 <code class=\"language-text\">coroutine</code> 객체는 <code class=\"language-text\">async def</code>를 사용하여 정의된 함수여야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">def</span> <span class=\"token function\">coroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'coroutine'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">await</span> asyncio<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\nloop <span class=\"token operator\">=</span> asyncio<span class=\"token punctuation\">.</span>get_event_loop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 더 이상 수행될 task가 없을때까지 무한히 loop를 돌며 전달받은 coroutine 객체를 처리</span>\nloop<span class=\"token punctuation\">.</span>run_until_complete<span class=\"token punctuation\">(</span>coroutine<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># event loop에 아직 실행이 종료되지 않은 task가 남아있다면, 모두 제거</span>\nloop<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br>\n<h3 id=\"future퓨쳐와-task테스크\" style=\"position:relative;\"><a href=\"#future%ED%93%A8%EC%B3%90%EC%99%80-task%ED%85%8C%EC%8A%A4%ED%81%AC\" aria-label=\"future퓨쳐와 task테스크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Future(퓨쳐)와 Task(테스크)</h3>\n<p><code class=\"language-text\">coroutine</code> 내부에서 다른 작업, 즉 <code class=\"language-text\">sub coroutine</code>을 수행하는 경우에는 <code class=\"language-text\">Future</code>, <code class=\"language-text\">Task</code>와 같은 <code class=\"language-text\">Awaitable</code>한 객체(실행을 종료할 때까지 기다릴 객체)를 <code class=\"language-text\">await</code>과 함께 사용해야 한다.</p>\n<p><code class=\"language-text\">Future</code>는 어떠한 작업의 실행 상태 및 결과를 저장하는 객체로, non-blocking 작업을 리턴한다고 볼 수 있다. <em>(작업의 실행을 시작하는 역할은 수행하지 않는다.)</em> <code class=\"language-text\">add_done_callback()</code>으로 완료 시에 호출할 콜백함수를 등록할 수 있고, <code class=\"language-text\">result()</code>로 실행결과를 반환한다.</p>\n<p><code class=\"language-text\">Task</code>는 <code class=\"language-text\">Future</code>를 상속한 객체로, 작업의 실행 상태 및 결과를 저장한다. <code class=\"language-text\">Future</code>와는 달리 작업의 실행을 개시하는 역할까지 수행한다. <code class=\"language-text\">asyncio.run()</code> 또는 <code class=\"language-text\">asyncio.create_task()</code>함수<text style=\"color:grey;\"> <em>(Python 3.6 이전에서는 <code class=\"language-text\">asyncio.ensure_future()</code>를 사용)</em> </text>를 호출할 때 <code class=\"language-text\">coroutine</code> 객체를 인자로 전달하면, <code class=\"language-text\">Task</code>객체가 생성되면서 전달받은 <code class=\"language-text\">coroutine</code>이 <code class=\"language-text\">Task</code>로 실행되도록 예약된다.</p>\n<br>\n<h2 id=\"event-loop가-coroutine을-실행하는-방식\" style=\"position:relative;\"><a href=\"#event-loop%EA%B0%80-coroutine%EC%9D%84-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"event loop가 coroutine을 실행하는 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Event Loop가 Coroutine을 실행하는 방식</h2>\n<p><code class=\"language-text\">coroutine</code> 객체의 생성 및 반환이 <code class=\"language-text\">coroutine</code>의 실행을 의미하지 않는다고 하였다. 아래는 <code class=\"language-text\">coroutine</code>을 실행하기 위한 방법들이다.</p>\n<p><strong>1. <code class=\"language-text\">await</code> syntax</strong></p>\n<p><code class=\"language-text\">coroutine</code> 내부에서만 사용할 수 있는 키워드이다. 따라서 <code class=\"language-text\">coroutine</code>을 처음 실행할 때는 사용할 수 없고, 다른 <code class=\"language-text\">coroutine</code> 내부에서 <code class=\"language-text\">sub coroutine</code>을 호출하는 경우에 사용할 수 있다. 다른 <code class=\"language-text\">coroutine</code>을 호출하고, 해당 작업이 완료될 때까지 기다린다. 또한 다른 <code class=\"language-text\">coroutine</code>에 대한 entry point라고도 이해할 수 있다.</p>\n<br>\n<p><strong>2. <code class=\"language-text\">asyncio.run()</code> 함수</strong></p>\n<p>    \n<strong>① 현재 실행 중인 thread에 새로운 event loop를 설정</strong>하고<br>\n    \n<strong>② 인자로 전달되는 <code class=\"language-text\">coroutine</code> 객체를 <code class=\"language-text\">task</code>로 예약하여 실행</strong>하고<br>\n    \n<strong>③<code class=\"language-text\">task</code>의 실행이 완료되면 event loop를 닫는 역할</strong>을 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">def</span> <span class=\"token function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n        loop <span class=\"token operator\">=</span> asyncio<span class=\"token punctuation\">.</span>get_running loop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">except</span> RuntimeError<span class=\"token punctuation\">:</span>\n        loop <span class=\"token operator\">=</span> asyncio<span class=\"token punctuation\">.</span>new_event_loop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">finally</span><span class=\"token punctuation\">:</span>\n        loop<span class=\"token punctuation\">.</span>run_until_complete<span class=\"token punctuation\">(</span>coroutine<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        loop<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p><strong><em>NOTE:</em></strong> <code class=\"language-text\">get_event_loop()</code>는 실행 중인 event loop를 가져오기 위해 사용하는 함수로, 실행 중인 event loop가 없는 경우, <code class=\"language-text\">RuntimeError</code>를 발생시킨다. Python 3.10 이상에서는 지원되지 않는 함수로, coroutine이나 callback에서는 <code class=\"language-text\">get_running_loop()</code>를 사용하는 것이 권장된다.</p>\n</blockquote>\n<br>\n<p><strong>3. <code class=\"language-text\">asyncio.create_task()</code>와 <code class=\"language-text\">asyncio.gather()</code> 함수</strong></p>\n<p><code class=\"language-text\">asyncio.run()</code>은 기본적으로 하나의 task를 실행한다. 따라서 여러 <code class=\"language-text\">Task</code>객체를 생성하여 실행하는 경우에만 동시적(concurrent)성이 보장된다고 할 수 있다.\n전달받은 여러 Awaitable 객체들이 완료될 때까지 기다렸다가, 그 완료 결과를 리스트 형태로 반환하는 함수가 바로 <code class=\"language-text\">asyncio.gather(*tasks)</code>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">def</span> <span class=\"token function\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    tasks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>asyncio<span class=\"token punctuation\">.</span>create_task<span class=\"token punctuation\">(</span>_function<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> data <span class=\"token keyword\">in</span> data_list<span class=\"token punctuation\">]</span> \n    results <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> asyncio<span class=\"token punctuation\">.</span>gather<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>tasks<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># [result_task_1, result_task_2, ...]</span>\n    <span class=\"token keyword\">return</span> results</code></pre></div>\n<br>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://docs.python.org/3/library/asyncio.html\">https://docs.python.org/3/library/asyncio.html</a></li>\n<li><a href=\"https://it-eldorado.tistory.com/159\">https://it-eldorado.tistory.com/159</a></li>\n<li><a href=\"https://soooprmx.com/asyncio/\">https://soooprmx.com/asyncio/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">비동기 프로그래밍과 동작원리</a></p>\n</li>\n<li>\n<p><a href=\"#coroutine%EC%BD%94%EB%A3%A8%ED%8B%B4\">Coroutine(코루틴)</a></p>\n<ul>\n<li><a href=\"#iterator%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0\">Iterator(이터레이터)</a></li>\n<li><a href=\"#generator%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0\">Generator(제너레이터)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#event-loop\">Event Loop</a></p>\n<ul>\n<li><a href=\"#future%ED%93%A8%EC%B3%90%EC%99%80-task%ED%85%8C%EC%8A%A4%ED%81%AC\">Future(퓨쳐)와 Task(테스크)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#event-loop%EA%B0%80-coroutine%EC%9D%84-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D\">Event Loop가 Coroutine을 실행하는 방식</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"May 14, 2023","title":"파이선에서 asyncio로 비동기 처리하기","categories":"python","author":"소희","emoji":"💭"},"fields":{"slug":"/python/asyncio/"}},"prev":{"id":"0b79f502-ecd3-5900-934b-025c9237986d","html":"<p><a href=\"https://soheeeep.github.io/api-architecture\">이전 포스팅: &#x3C;어떤 API를 사용해야 할까? - REST, GraphQL, 그리고 GRPC></a>에서 다양한 API 형식에 대하여 소개했다. 그 중 REST는 <code class=\"language-text\">HTTP/1.1</code> 프로토콜을 기반으로 동작한다면, gRPC는 <code class=\"language-text\">HTTP/2.0</code> 프로콜을 기반으로 동작한다는 점이 가장 큰 차이점이었다.</p>\n<p>그동안 HTTP와 HTTPS를 <strong>‘웹에서 동작하는 어플리케이션을 만들기 위해 정의된 클라이언트-서버 모델의 프로토콜’</strong> 정도의 넓은 개념으로만 이해하고 있었다. 시간의 흐름에 따라 발전해온 HTTP 프로토콜의 버전과 그 특징에 대하여 자세하게 알아보려고 한다.</p>\n<br>\n<h2 id=\"웹은-어떻게-동작하는가\" style=\"position:relative;\"><a href=\"#%EC%9B%B9%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"웹은 어떻게 동작하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹은 어떻게 동작하는가?</h2>\n<p>인터넷이 메세지를 routing할 수 있는 <code class=\"language-text\">IP(Internet Protocol)</code>을 기반으로 연결된 public한 computer들의 집합이라는 넓은 개념이라면, Web은 이메일, 파일 공유처럼 인터넷을 구성하는 여러 서비스 중 하나라고 말할 수 있다.</p>\n<blockquote>\n<p><strong><em>IP(Internel Protocol)</em>:</strong> 송신 호스트와 수신 호스트 사이에서 패킷이 네트워크를 통해 이동할 수 있도록 데이터를 라우팅하는 네트워크 계층의 프로토콜</p>\n</blockquote>\n<p>각 서비스에 대하여 인터넷을 통해 메세지를 라우팅하고 리소스를 주고받기 위한 표준과 프로토콜이 존재한다.\n이메일이 <code class=\"language-text\">SMTP, IMAP, POP 프로토콜</code>을 이용한다면, web은 <code class=\"language-text\">HTTP</code>을 통해 멀리 떨어진 다른 서버에 대한 리소스를 요청하고 응답받는다.</p>\n<br>\n<h2 id=\"http의-정의와-동작-방식\" style=\"position:relative;\"><a href=\"#http%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"http의 정의와 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP의 정의와 동작 방식</h2>\n<p><code class=\"language-text\">HTTP(Hypertext Transfer Protocol)</code>은 여러 종류의 파일(문서에 대한 링크, 이미지와 같은 다양한 형태)을 주고받는 프로토콜이다. HTTP는 신뢰성 있는 네트워크를 기반으로 동작하고, 여러 계층으로 나누어 통신을 수행한다. 각 계층은 독립적이지만 논리적으로 연결되어 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIBAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQP/2gAMAwEAAhADEAAAAfVmsx10QyZl6pH/xAAaEAACAwEBAAAAAAAAAAAAAAAAEQECEgMg/9oACAEBAAEFAkZF4ZEjN2I6WN2P/8QAFxEBAAMAAAAAAAAAAAAAAAAAABAREv/aAAgBAwEBPwGKZf/EABcRAAMBAAAAAAAAAAAAAAAAAAABEhD/2gAIAQIBAT8BykUj/8QAGxABAAIDAQEAAAAAAAAAAAAAAAEyAjFCM5H/2gAIAQEABj8CpLzn6pLtrN2tkvktLbbb/8QAGhAAAwEBAQEAAAAAAAAAAAAAAAER4VEQIf/aAAgBAQABPyGdhICdiLgSQxcEZCMCMz5CnwP/2gAMAwEAAgADAAAAEEP78//EABgRAAMBAQAAAAAAAAAAAAAAAAAR8PEB/9oACAEDAQE/EH20fbR7BrD/xAAZEQADAQEBAAAAAAAAAAAAAAAAAfAR0fH/2gAIAQIBAT8QxXhis4RMiZ//xAAfEAEAAgEEAwEAAAAAAAAAAAABABEhEHGBkTFhoeH/2gAIAQEAAT8Qaq65JeHQFMvjGW3DzD96YpMun30WRb5bEZR+Se50T//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"web-http-transport-layer.jpeg\"\n        title=\"web-http-transport-layer.jpeg\"\n        src=\"/static/8fd15ddd7e45d03d0b124d134151f998/1c72d/web-http-transport-layer.jpg\"\n        srcset=\"/static/8fd15ddd7e45d03d0b124d134151f998/4ec73/web-http-transport-layer.jpg 180w,\n/static/8fd15ddd7e45d03d0b124d134151f998/158ba/web-http-transport-layer.jpg 360w,\n/static/8fd15ddd7e45d03d0b124d134151f998/1c72d/web-http-transport-layer.jpg 590w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><em>가장 보편적으로 적용되는 OSI(Open Systems Interconection) 7계층 모델</em></p>\n<br>\n<h3 id=\"전송transport-계층의-프로토콜-tcp와-udp\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EC%86%A1transport-%EA%B3%84%EC%B8%B5%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-tcp%EC%99%80-udp\" aria-label=\"전송transport 계층의 프로토콜 tcp와 udp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전송(Transport) 계층의 프로토콜, TCP와 UDP</h3>\n<p>데이터를 주고받는 전송 계층의 프로토콜 중 가장 대표적인 것에는 <code class=\"language-text\">TCP(Transmission Control Protocol)</code>과 <code class=\"language-text\">UDP(User Diagram Protocol)</code>이 있다. IP를 통해 전달되는 패킷에 대한 오류 검출, 재전송 요구 제어 등을 수행하여 데이터를 전달해주는 역할을 수행한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"left\">TCP</th>\n<th align=\"left\">UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">연결 방식</td>\n<td align=\"left\">연결형 서비스</td>\n<td align=\"left\">비연결형 서비스</td>\n</tr>\n<tr>\n<td align=\"center\">패킷 교환</td>\n<td align=\"left\">가상회선 방식</td>\n<td align=\"left\">데이터그램 방식</td>\n</tr>\n<tr>\n<td align=\"center\">전송 속도</td>\n<td align=\"left\">느림</td>\n<td align=\"left\">빠름</td>\n</tr>\n<tr>\n<td align=\"center\">연결 설정</td>\n<td align=\"left\">handshaking을 통해 연결을 설정하고<br>해제하는 과정이 존재하지 않음</td>\n<td align=\"left\">연결을 설정하기 위한<br>별도의 과정이 존재하지 않음</td>\n</tr>\n<tr>\n<td align=\"center\">신뢰성</td>\n<td align=\"left\">데이터의 전송순서를 보장하며, <br>신뢰성이 높음</td>\n<td align=\"left\">데이터의 전송순서를 보장하지 않으며,<br>신뢰성이 낮음</td>\n</tr>\n</tbody>\n</table>\n<p>위의 표를 통해 <strong>TCP는 신뢰성이 높지만 상대적으로 느린, UDP는 신뢰성이 낮지만 상대적으로 빠른 프로토콜</strong>이라고 정리할 수 있다. TCP는 전송되는 데이터 패킷들의 순서를 보장하고, 패킷 손실 여부 등을 검사하여 송신 측에서 보낸 데이터가 수신 측에 온전하게 전달되는 것을 보장한다.</p>\n<br>\n<h3 id=\"http10\" style=\"position:relative;\"><a href=\"#http10\" aria-label=\"http10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP/1.0</h3>\n<p><code class=\"language-text\">HTTP/1.0</code>에서는 문서뿐만 아니라 이미지, CSS와 같이 다양한 파일을 주고 받을 수 있다.</p>\n<ul>\n<li><strong>하나의 TCP 연결에 대해 하나의 요청을 처리할 수 있도록 구현</strong>되어있다. 세션을 유지하지 않으므로, TCP 연결을 지속하려면 <code class=\"language-text\">Connection: keep-alive</code> 헤더를 설정해야 해주어야 하는 <code class=\"language-text\">Non-Persistent</code> 프토토콜이다.</li>\n<li><strong><code class=\"language-text\">Pipelining</code>을 제공하지 않아 하나의 요청에 대한 응답을 받은 후에 다른 요청을 수행할 수 있으므로</strong>, <code class=\"language-text\">RTT(Round Trip Time)</code>이 증가하고 network latency가 발생하게 된다.</li>\n<li><strong>하나의 IP 주소에 대하여 여러 도메인을 운영할 수 없고</strong>, 클라이언트와 서버 사이에 proxy가 위치하는 경우 <strong>proxy가 클라이언트에 대한 인증을 수행할 수 없다</strong>는 한계가 있었다.</li>\n</ul>\n<br>\n<h3 id=\"http11\" style=\"position:relative;\"><a href=\"#http11\" aria-label=\"http11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP/1.1</h3>\n<p><code class=\"language-text\">HTTP/1.0</code>과 가장 크게 달라진 점은 <strong>TCP 연결의 지속성</strong>이다.</p>\n<ul>\n<li><strong>별도의 헤더를 설정하지 않고도 지정된 timeout 동안은 연결을 유지</strong>한다. 또한 요청마다 TCP 연결을 수립해야 하는 <code class=\"language-text\">HTTP/1.0</code>과 달리, 한 개의 TCP 세션을 통해 여러 요청을 처리하여 부하를 줄일 수 있게 <code class=\"language-text\">Persistent</code>한 프로토콜로 개선되었다.</li>\n<li><strong>연결 내에서 응답을 기다리지 않고 순차적으로 여러 요청을 보낼 수 있는 <code class=\"language-text\">Pipelining</code>이 적용</strong>되며 network latency가 개선되었다.</li>\n<li>Host 헤더를 추가하여 <strong>하나의 IP에 여러 도메인을 운영하는</strong> <code class=\"language-text\">Virtual Hosting</code>이 가능해졌다.</li>\n<li><code class=\"language-text\">proxy-authentication</code>, <code class=\"language-text\">proxy-authorization</code> 헤더를 사용하여 proxy도 클라이언트에 대한 인증을 수행할 수 있게 되며 <strong>인증절차가 강화</strong>되었다.</li>\n<li>새로운 상태 코드가 추가되고, caching이 개선되는 등 전체적인 성능이 향상되었다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADM0lEQVQ4y21UiW7rOAzM//9b0QPY3knbJC/Ni23ZukydngXp2MgCS0BQzIij4ZDUZpomsIUQkHOR37XW+TslEJF8L/4YI3LOGMcR5epnDD6fUsIGVzPGCIAcqBVt28JaJ/6UIkch54TL5SJgWmuUUpZwOc9nN6VUOOfQqAE+ZMRcUScIuHMWl66HMh7W07ysE3/Xa5gxIZeKUiakGGGtxYbp932PkUgO2JDhY8HfYcTgSFKkVOFikb2xEYP10DSiDQmNT2jHhLMmKO2ZYRHAFAMni1wnCfztPYxnHed0U6kIqaC1QZgGZzCSgyYHnwj/dBoHbWaGehhw7i0aE2BoZhhTkrT/9g69i3CUQbFi4guJEGgEIi8POxjsTz+wQ3tlqBTaTqGWuoocYhCRO+dxJoIvGVQLiHciUAhzMali7wleN0jezoBDP6A3BmPJK2DNGd45aQdui7EUuJxxHD0uzqKkmfXejvBOYYoEigkbTk11HXrnoGJAEwOGnKBohCWS6sVahOGQIroQ4IkLMOLgAoztgETSGXz5hqvIvZWI1iZlNjujYQPhj7VoQoDNGVnKBqQQ8G0cWtPNOnJGpcyAnLI1BhfncCFCGwN0zrAhSGGC05hcD5CdmQQvBdFDgzIaXFmsU7TJ16Icu04EX2xpVAadZHoKpuBR1AmkFYxqBWgZXR47nh5h2CmF0TmOwrQA5gznPaI3qORQR4OJLKYUEFjbUgRsAVwZlpLRDwO8VihWSRDrksiLJrr5RQ1uDSx1gnN+1ft2Z1tTDjHOqXHaKSCqX0SnMYar/xowz7hbgZjZwpTXXBTnEL0VkVknZpmc/s/rU69rsVtWtz5pm7f3D/S/BxTWKs0TwJPARfk/W8B4kg6HA5RSMj2SMt/K1eGUb20RmY0Dfn5+cD6f5Q1cABns7u4Oj4+P6LpuBrwFaS4XfO12OB6P8N6v/u/vbwm6v79f9dvv93h/f8fX1xdeXl7w8fGBpmmwWYRlY6CHhwc8PT1JOmz8Ou+2W2y3Wwk8nU7iF6ne3vD8/IzX11fJQNpmbYdSBJADPz8/ZRzZGIBv54Ddbif/DcMw60wkTDkuXQv4L2I5W6FV78H3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"web-http-1.0-1.1.png\"\n        title=\"web-http-1.0-1.1.png\"\n        src=\"/static/03e07b40859a2a790e34697b7ead0c08/37523/web-http-1.0-1.1.png\"\n        srcset=\"/static/03e07b40859a2a790e34697b7ead0c08/e9ff0/web-http-1.0-1.1.png 180w,\n/static/03e07b40859a2a790e34697b7ead0c08/f21e7/web-http-1.0-1.1.png 360w,\n/static/03e07b40859a2a790e34697b7ead0c08/37523/web-http-1.0-1.1.png 720w,\n/static/03e07b40859a2a790e34697b7ead0c08/302a4/web-http-1.0-1.1.png 1080w,\n/static/03e07b40859a2a790e34697b7ead0c08/fe9e8/web-http-1.0-1.1.png 1146w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br>\n<h3 id=\"holbhead-of-line-blocking\" style=\"position:relative;\"><a href=\"#holbhead-of-line-blocking\" aria-label=\"holbhead of line blocking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HOLB(Head of Line Blocking)</h3>\n<p>기본적으로 <code class=\"language-text\">HTTP/1</code>에서는 TCP 프로토콜을 사용하므로, 패킷은 무조건 전송받은 순서대로 처리되는 것이 보장된다. 수신 측은 송신 측과 sequence 번호를 주고받으며 순서대로 패킷을 재조립하고, 패킷이 손실 또는 유실되었을 경우 재전송을 수행하게 된다. 요청이 처리되는 순서가 정해져 있으므로, 이전에 받은 패킷을 파싱하기 전가지는 다음 패킷을 처리할 수도 없어서 <code class=\"language-text\">Pipelining</code>을 활용하는 것 또한 쉽지 않다. 이렇게 <strong>패킷이 유실되거나 송신 측의 전송 속도와 수신 측의 패킷 처리 속도가 상이한 경우 발생하는 병목현상</strong>을 <code class=\"language-text\">HOLB(Head of Line Blocking)</code>라고 부른다.</p>\n<p>또한 TCP에서는 신뢰성 있는 연결을 위해 handshaking을 반복적으로 수행하기 때문에 여전히 불필요한 <code class=\"language-text\">RTT(Round Trip Time)</code>, 이에 따른 네트워크 지연이 발생한다는 문제도 남아있다.</p>\n<h3 id=\"다수의-요청으로-인해-무거워지는-header\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%88%98%EC%9D%98-%EC%9A%94%EC%B2%AD%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%B4-%EB%AC%B4%EA%B1%B0%EC%9B%8C%EC%A7%80%EB%8A%94-header\" aria-label=\"다수의 요청으로 인해 무거워지는 header permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다수의 요청으로 인해 무거워지는 Header</h3>\n<p>클라이언트와 서버 사이의 요청을 처리할 때마다 헤더를 중복해서 전송하며 불필요한 데이터를 주고받게 된다. cookie 정보 또한 매 요청마다 헤더에 포함되어 전송하므로 네트워크 자원이 낭비되는 문제가 발생한다.</p>\n<br>\n<h2 id=\"http2의-출현\" style=\"position:relative;\"><a href=\"#http2%EC%9D%98-%EC%B6%9C%ED%98%84\" aria-label=\"http2의 출현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP/2의 출현</h2>\n<p>방대해지는 데이터, multi-media 리소스 처리비용의 증가, 비동기 처리에 대한 소요 증가 등 웹이 고도화됨에 따라 <code class=\"language-text\">HTTP/1.1</code>의 한계는 더욱 명확해졌다.</p>\n<br>\n<p>두 개의 이미지가 있는 하나의 정적인 웹 페이지를 로딩하는 과정을 예시로 들어 하나의 요청을 처리하는데 소요되는 시간을 50ms, 정적인 이미지를 받아오는 시간을 10ms라고 하자.\n페이지를 로딩하기 위해서는 360ms가 소요되는 반면, 그 중 실제로 요청을 처리하는 시간은 60ms에 불과하다. 하나의 요청이 완료되기 전까지는 다음 요청을 처리할 수 없으므로 거의 80% 이상의 시간이 메세지를 기다리는 시간으로 낭비되는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 116.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7ZQCaCA//EABgQAAMBAQAAAAAAAAAAAAAAAAARIRAg/9oACAEBAAEFApl4cEf/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAVEAEBAAAAAAAAAAAAAAAAAAAgMf/aAAgBAQAGPwI0f//EABoQAAIDAQEAAAAAAAAAAAAAAAABESExcYH/2gAIAQEAAT8hxcHDyJpKzcIYUEo06Z//2gAMAwEAAgADAAAAEFAAAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB4QAAICAgIDAAAAAAAAAAAAAAERADEhQXGBUWGR/9oACAEBAAE/EGAOFpzKr3UHkfkwJQ5enKZL3AnLdQGYN1zEmxxcCb+5/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"web-http-1-flow.jpeg\"\n        title=\"web-http-1-flow.jpeg\"\n        src=\"/static/c5834a4c1421fb4ad7b63e6d053bc516/1c72d/web-http-1-flow.jpg\"\n        srcset=\"/static/c5834a4c1421fb4ad7b63e6d053bc516/4ec73/web-http-1-flow.jpg 180w,\n/static/c5834a4c1421fb4ad7b63e6d053bc516/158ba/web-http-1-flow.jpg 360w,\n/static/c5834a4c1421fb4ad7b63e6d053bc516/1c72d/web-http-1-flow.jpg 590w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>아래는 위의 예시에 <code class=\"language-text\">Pipelining</code>을 적용한 것이다. 위의 예시와 비교하면 성능의 향상은 이루어졌다고 볼 수 있지만, 여전히 낭비되는 시간이 많다. 또한 실제 운영환경의 웹 사이트는 훨씬 많은 데이터를 담고 있기 때문에, 지연은 더욱 커질 것이고 이에 따라 성능은 더욱 저하될 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHu2UIMdgUH/8QAFxABAQEBAAAAAAAAAAAAAAAAIRAAIP/aAAgBAQABBQIjiPH/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAYEAACAwAAAAAAAAAAAAAAAAAAIRAgMf/aAAgBAQAGPwKWI2n/xAAcEAACAgIDAAAAAAAAAAAAAAAAARExECFBcYH/2gAIAQEAAT8hpuDo8koloWEuaDpCrH//2gAMAwEAAgADAAAAEMAPAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB4QAAICAgIDAAAAAAAAAAAAAAERADEQYSFRQYGR/9oACAEBAAE/ECQBw6c5VfdQdj8mFoaOFhyW/ERsaGFRj//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"web-http-1-pipelining.jpeg\"\n        title=\"web-http-1-pipelining.jpeg\"\n        src=\"/static/ce4ff05fb06ef24a0912127e646881ab/1c72d/web-http-1-pipelining.jpg\"\n        srcset=\"/static/ce4ff05fb06ef24a0912127e646881ab/4ec73/web-http-1-pipelining.jpg 180w,\n/static/ce4ff05fb06ef24a0912127e646881ab/158ba/web-http-1-pipelining.jpg 360w,\n/static/ce4ff05fb06ef24a0912127e646881ab/1c72d/web-http-1-pipelining.jpg 590w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><br><br></p>\n<p>당시 새로운 해결책은 더 많은 TCP 연결을 여는 것이었다. 각 connection들은 서로 독립적으로 동작하므로 <code class=\"language-text\">Pipelining</code>이나 <code class=\"language-text\">HOLB</code>에 따른 문제를 해결할 수 있었고 병렬성을 적용하여 HTTP 헤더가 방대해지는 문제도 어느 정도 해결할 수 있었다.\n또한 이미지, <code class=\"language-text\">CSS</code>, <code class=\"language-text\">JS</code>와 같은 static 리소스들을 서브 도메인에서 처리하도록 하는 <code class=\"language-text\">Domain Sharding</code>, HTML 문서 내의 이미지 리소스를 Base64로 인코딩된 이미지 데이터로 직접 작성하여 네트워크 요청을 줄이는 방법 등 다양한 성능 개선을 시도했다.</p>\n<p>하지만 이러한 해결책의 한계는 명확했다. 클라이언트와 서버 사이의 connection이 증가하며 발생하는 overhead, TCP 연결을 수립하는 과정에서 발생하는 네트워크 지연, 연결을 유지하기 위해 소모되는 메모리와 processing 비용 등 다양한 요소들이 아직 해결하지 못한 과제로 남아있었다.</p>\n<br>\n<p>이후 2015년, Google의 SPDY 프로토콜을 기반으로 한 <code class=\"language-text\">HTTP/2.0</code>이 출현하였다. <code class=\"language-text\">HTTP2</code> 공식 깃허브의 README에 기술된 내용에 따르면, <text style=\"color:#000066;\"><strong><code class=\"language-text\">HTTP/2.0</code>은 완전히 새로운 프로토콜이 아닌 성능 향상에 초점을 맞춘 버전</strong></text>이다.<br>\n<code class=\"language-text\">HTTP/2</code> 명세인 <a href=\"https://httpwg.org/specs/rfc7540.html\">RFC 7540</a>은 2015년 5월 발행된 뒤 구현, 배포되었다.</p>\n<blockquote>\n<p>“HTTP/2 is a replacement for how HTTP is expressed “on the wire.” It is not a ground-up rewrite of the protocol; HTTP methods, status codes and semantics are the same, and it should be possible to use the same APIs as HTTP/1.x (possibly with some small additions) to represent the protocol. <strong>The focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage.</strong> One major goal is to allow the use of a single connection from browsers to a Web site.”</p>\n</blockquote>\n<br>\n<p><code class=\"language-text\">HTTP/2.0</code>에서 개선된 주요한 기능들은 다음과 같은 것들이 있다.</p>\n<br>\n<h3 id=\"multiplexed-streams을-통한-pipelining의-개선\" style=\"position:relative;\"><a href=\"#multiplexed-streams%EC%9D%84-%ED%86%B5%ED%95%9C-pipelining%EC%9D%98-%EA%B0%9C%EC%84%A0\" aria-label=\"multiplexed streams을 통한 pipelining의 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multiplexed Streams을 통한 Pipelining의 개선</h3>\n<p>TCP 연결 한 개로 동시에 여러 메세지를 주고받을 수 있게 되었다. 요쳥 순서에 관계없이 Stream을 통해 클라이언트와 서버는 양방향으로 Message를 주고 받을 수 있게 되었다.</p>\n<p>HTTP/2.0을 기반으로 동작하는 gRPC의 경우,</p>\n<ul>\n<li>클라이언트에서 서버로 stream을 전달하고, 서버에서는 한 번 응답하는 <code class=\"language-text\">Client-side Streaming</code></li>\n<li>클라이언트에서 한 번 전달, 서버에서는 stream으로 응답하는 <code class=\"language-text\">Server-side Streaming</code></li>\n<li>클라이언트와 서버 모두에서 stream으로 요청, 응답하는 <code class=\"language-text\">Bidirectional Streaming</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// stream을 사용해 통신방식을 정의하여 gRPC Service를 생성</span>\nservice User <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// unary: 한 번의 호출에 대해 한 번 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// client-stream: 클라이언트에서 서버로 stream을 전달하고, 서버에서는 한 번 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>stream GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// server-stream: 클라이언트에서 한 번 전달, 서버에서는 stream으로 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>stream GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// bidirectional stream: 클라이언트와 서버 모두에서 stream으로 요청, 응답</span>\n    rpc <span class=\"token function\">GetUser</span><span class=\"token punctuation\">(</span>stream GetUserRequest<span class=\"token punctuation\">)</span> returns <span class=\"token punctuation\">(</span>stream GetUserResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"stream-prioritization-리소스-간의-의존관계를-정의\" style=\"position:relative;\"><a href=\"#stream-prioritization-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EA%B0%84%EC%9D%98-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84%EB%A5%BC-%EC%A0%95%EC%9D%98\" aria-label=\"stream prioritization 리소스 간의 의존관계를 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stream Prioritization: 리소스 간의 의존관계를 정의</h3>\n<h3 id=\"server-push를-통한-클라이언트-요청-최소화\" style=\"position:relative;\"><a href=\"#server-push%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9A%94%EC%B2%AD-%EC%B5%9C%EC%86%8C%ED%99%94\" aria-label=\"server push를 통한 클라이언트 요청 최소화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server Push를 통한 클라이언트 요청 최소화</h3>\n<h3 id=\"header-compression을-통한-불필요한-부하-감소\" style=\"position:relative;\"><a href=\"#header-compression%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EB%B6%80%ED%95%98-%EA%B0%90%EC%86%8C\" aria-label=\"header compression을 통한 불필요한 부하 감소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Header Compression을 통한 불필요한 부하 감소</h3>\n<h3 id=\"http2-기반으로-동작하는-rpc\" style=\"position:relative;\"><a href=\"#http2-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-rpc\" aria-label=\"http2 기반으로 동작하는 rpc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP/2 기반으로 동작하는 RPC</h3>\n<br>\n<text style=\"color:grey;\">\n<h2 id=\"udp-기반으로-동작하는-http\" style=\"position:relative;\"><a href=\"#udp-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-http\" aria-label=\"udp 기반으로 동작하는 http permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP 기반으로 동작하는 HTTP?</h2>\n<h3 id=\"http3\" style=\"position:relative;\"><a href=\"#http3\" aria-label=\"http3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP/3</h3>\n<h3 id=\"udp-기반으로-동작하는-프로토콜-quic\" style=\"position:relative;\"><a href=\"#udp-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-quic\" aria-label=\"udp 기반으로 동작하는 프로토콜 quic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UDP 기반으로 동작하는 프로토콜, QUIC</h3>\n<h3 id=\"http3이-udp를-사용함으로서-얻은-이점\" style=\"position:relative;\"><a href=\"#http3%EC%9D%B4-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%84%9C-%EC%96%BB%EC%9D%80-%EC%9D%B4%EC%A0%90\" aria-label=\"http3이 udp를 사용함으로서 얻은 이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP/3이 UDP를 사용함으로서 얻은 이점</h3>\n<br>\n</text>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<ul>\n<li><a href=\"https://www.oreilly.com/library/view/http2-in-action/9781617295164/\">Barry Pollard (2019). HTTP/2 in Action. Manning Publications</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%9B%B9%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80\">웹은 어떻게 동작하는가?</a></p>\n</li>\n<li>\n<p><a href=\"#http%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">HTTP의 정의와 동작 방식</a></p>\n<ul>\n<li><a href=\"#%EC%A0%84%EC%86%A1transport-%EA%B3%84%EC%B8%B5%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-tcp%EC%99%80-udp\">전송(Transport) 계층의 프로토콜, TCP와 UDP</a></li>\n<li><a href=\"#http10\">HTTP/1.0</a></li>\n<li><a href=\"#http11\">HTTP/1.1</a></li>\n<li><a href=\"#holbhead-of-line-blocking\">HOLB(Head of Line Blocking)</a></li>\n<li><a href=\"#%EB%8B%A4%EC%88%98%EC%9D%98-%EC%9A%94%EC%B2%AD%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%B4-%EB%AC%B4%EA%B1%B0%EC%9B%8C%EC%A7%80%EB%8A%94-header\">다수의 요청으로 인해 무거워지는 Header</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http2%EC%9D%98-%EC%B6%9C%ED%98%84\">HTTP/2의 출현</a></p>\n<ul>\n<li><a href=\"#multiplexed-streams%EC%9D%84-%ED%86%B5%ED%95%9C-pipelining%EC%9D%98-%EA%B0%9C%EC%84%A0\">Multiplexed Streams을 통한 Pipelining의 개선</a></li>\n<li><a href=\"#stream-prioritization-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EA%B0%84%EC%9D%98-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84%EB%A5%BC-%EC%A0%95%EC%9D%98\">Stream Prioritization: 리소스 간의 의존관계를 정의</a></li>\n<li><a href=\"#server-push%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9A%94%EC%B2%AD-%EC%B5%9C%EC%86%8C%ED%99%94\">Server Push를 통한 클라이언트 요청 최소화</a></li>\n<li><a href=\"#header-compression%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EB%B6%80%ED%95%98-%EA%B0%90%EC%86%8C\">Header Compression을 통한 불필요한 부하 감소</a></li>\n<li><a href=\"#http2-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-rpc\">HTTP/2 기반으로 동작하는 RPC</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#udp-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-http\">UDP 기반으로 동작하는 HTTP?</a></p>\n<ul>\n<li><a href=\"#http3\">HTTP/3</a></li>\n<li><a href=\"#udp-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-quic\">UDP 기반으로 동작하는 프로토콜, QUIC</a></li>\n<li><a href=\"#http3%EC%9D%B4-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%84%9C-%EC%96%BB%EC%9D%80-%EC%9D%B4%EC%A0%90\">HTTP/3이 UDP를 사용함으로서 얻은 이점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#references\">References</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 03, 2023","title":"HTTP/2.0 프로토콜 알아보기","categories":"네트워크","author":"소희","emoji":"🐤"},"fields":{"slug":"/web-http/"}},"site":{"siteMetadata":{"siteUrl":"https://soheeeep.github.io","comments":{"utterances":{"repo":"https://github.com/soheeeeP/soheeeep.github.io"}}}}},"pageContext":{"slug":"/api-architecture/","nextSlug":"/python/asyncio/","prevSlug":"/web-http/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}